macro(BuildLah_use_default_settings)
    message(STATUS "you are using SGEXTN version 6.1.0, BuildLah CMake integration")
    message(STATUS "for compiler and platform information, see version.txt in your build folder")
    message(STATUS "ensure that you have a complete installation of pre built Qt in addition to Qt shader tools, you may get this from either aqt or the Qt Maintenance Tool")
    message(STATUS "the output of BuildLah, which is whatever you find in the build folder after compilation finishes, is NOT READY FOR DISTRIBUTION, you must properly packaged it first, but very conveniently, that is extremely easy to do using GitHub Actions as long as you are ok with open sourcing your code")
    message(STATUS "building and using of static libraries is not supported in BuildLah and should not be done due to Qt and SGEXTN licensing issues")
    message(STATUS "building and using of C++ 20 modules is not supported in BuildLah, use shared libraries instead")
    message(STATUS "only compilation of the C++ language and compatible parts of C are supported directly in CodeLah, compilation of GLSL is supported through Qt shader tools")
    set(BUILDLAH_INIT ON)
    message(STATUS "starting BuildLah")

    message(STATUS "applying SGEXTN default settings")
    set(CMAKE_ERROR_DEPRECATED ON)
    set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
    set(CMAKE_SHARED_LIBRARY_ENABLE_EXPORTS ON)
    set(CMAKE_AUTOMOC ON)
    set(CMAKE_AUTORCC ON)
    if(APPLE)
        set(CMAKE_BUILD_RPATH "@executable_path/../Frameworks;@loader_path/../Frameworks")
        set(CMAKE_INSTALL_RPATH "@executable_path/../Frameworks;@loader_path/../Frameworks")
    elseif(UNIX)
        set(CMAKE_BUILD_RPATH "$ORIGIN/../lib:$ORIGIN/../plugins")
        set(CMAKE_INSTALL_RPATH "$ORIGIN/../lib:$ORIGIN/../plugins")
    endif()
    set(CMAKE_SKIP_RPATH FALSE)
    set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
    set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
    set(CMAKE_INCLUDE_CURRENT_DIR OFF)
    set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE OFF)
    set(CMAKE_OPTIMIZE_DEPENDENCIES ON)
    set(CMAKE_POSITION_INDEPENDENT_CODE ON)
    set(CMAKE_VISIBILITY_INLINES_HIDDEN ON)
    set(CMAKE_CXX_EXTENSIONS OFF)
    set(CMAKE_CXX_STANDARD 20)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE NEVER)
    set(QT_NO_PRIVATE_MODULE_WARNING ON)

    set_property(DIRECTORY . PROPERTY GLOBAL_DEPENDS_NO_CYCLES ON)
    set_property(DIRECTORY . PROPERTY REPORT_UNDEFINED_PROPERTIES ON)
    set_property(DIRECTORY . PROPERTY TARGET_SUPPORTS_SHARED_LIBS ON)

    if(${CMAKE_BUILD_TYPE} STREQUAL "Debug")
        message(WARNING "building in DEBUG mode, this should NOT be released")
    endif()
endmacro()

macro(BuildLah_find_dependencies)
    message(STATUS "BuildLah will now begin checks ensuring Qt libraries are present")
    message(STATUS "if an error occurs, ensure that you installed Qt properly using aqt or the Qt Maintenance Tool, asking a friend to send you their Qt stuff in a zip file is NOT a proper installation")
    message(STATUS "also ensure that you have Shader Tools installed, they are in a separate module")
    find_package(Qt6 REQUIRED COMPONENTS Core Gui Qml Quick QuickControls2 QuickDialogs2 GuiPrivate ShaderTools OpenGL Network)
    message(STATUS "Qt libraries are present")
    if(APPLE)
        foreach(_tgt Qt6::Core Qt6::Gui Qt6::Qml Qt6::Quick Qt6::QuickControls2 Qt6::QuickDialogs2 Qt6::GuiPrivate Qt6::ShaderTools Qt6::OpenGL Qt6::Network)
            if(TARGET ${_tgt})
                get_target_property(_loc ${_tgt} IMPORTED_LOCATION_RELEASE)
                get_target_property(_loc_dbg ${_tgt} IMPORTED_LOCATION_DEBUG)
                if(_loc)
                    set_target_properties(${_tgt} PROPERTIES IMPORTED_IMPLIB_RELEASE "${_loc}")
                endif()
                if(_loc_dbg)
                    set_target_properties(${_tgt} PROPERTIES IMPORTED_IMPLIB_DEBUG "${_loc_dbg}")
                endif()
            endif()
        endforeach()
    endif()

    if(${PROJECT_NAME} STREQUAL "SGEXTN")
        message(STATUS "BuildLah is being used to build SGEXTN, skipping checks for presence of SGEXTN libraries")
    else()
        message(STATUS "BuildLah will now begin checks ensuring that SGEXTN libraries are present")
        message(STATUS "SGEXTN is required to use BuildLah, so if this fails, you corrupted your PATH somehow while BuildLah is running, such precise timing is honestly an achievement")
        include("${SGEXTN_INSTALL_FOLDER}/SGEXTNConfig.cmake")
        foreach(comp IN ITEMS SG_Containers SG_Math SG_Core SG_FileSystem SG_Widgets SG_RI EntryPoint_SG)
            if(NOT TARGET SGEXTN::${comp})
                message(FATAL_ERROR "cannot find SGEXTN::${comp}, your copy of SGEXTN is likely not properly installed, corrupted or outdated, consider re installing")
            endif()
        endforeach()
        message(STATUS "SGEXTN libraries are present")
    endif()

    message(STATUS "BuildLah will now write the version.txt file")
    set(BUILDLAH_VERSION_PATH "${CMAKE_BINARY_DIR}/version.txt")
    message(STATUS "the file will be located at: ${BUILDLAH_VERSION_PATH}")
    file(WRITE ${BUILDLAH_VERSION_PATH} "BuildLah version information\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "CMake version: ${CMAKE_VERSION}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "generator: ${CMAKE_GENERATOR}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "build type: ${CMAKE_BUILD_TYPE}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "target operating system: ${CMAKE_SYSTEM_NAME}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "target operating system version: ${CMAKE_SYSTEM_VERSION}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "target operating system architecture: ${CMAKE_SYSTEM_PROCESSOR}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "host operating system: ${CMAKE_HOST_SYSTEM_NAME}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "host operating system version: ${CMAKE_HOST_SYSTEM_VERSION}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "host operating system architecture: ${CMAKE_HOST_SYSTEM_PROCESSOR}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "compiler name: ${CMAKE_CXX_COMPILER_ID}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "compiler version: ${CMAKE_CXX_COMPILER_VERSION}\n")
    set(QT6_VERSION "${QTCORE_VER}.${QTCORE_MINOR}.${QTCORE_PATCH}")
    file(APPEND ${BUILDLAH_VERSION_PATH} "Qt version: ${Qt6_VERSION}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "SGEXTN version: 6.1.0\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "project name: ${PROJECT_NAME}\n")
    file(APPEND ${BUILDLAH_VERSION_PATH} "project version: ${PROJECT_VERSION}\n")

    message(STATUS "searching for Qt plugins")
    message(STATUS "the plugins designer, help, printsupport, qmllint, qmlls, qmltooling, sqldrivers are excluded by default, if you need any of these, re define EXCLUDE_PLUGINS immediately after the call to BuildLah_find_dependencies")
    message(STATUS "desktop platforms, that is Windows, MacOS, and Linux, ignore this because windeployqt, macdeployqt, and linuxdeployqt are used for copying plugins and those do not see the CMake file")
    set(EXCLUDE_PLUGINS designer help printsupport qmllint qmlls qmltooling sqldrivers)
    file(GLOB PLUGIN_TYPE_FOLDERS "${Qt6_DIR}/plugins/*")
    foreach(TYPE_FOLDER ${PLUGIN_TYPE_FOLDERS})
        get_filename_component(TYPE_NAME ${TYPE_FOLDER} NAME)
        if(NOT TYPE_NAME IN_LIST EXCLUDE_PLUGINS)
            message(STATUS "the plugin ${TYPE_NAME} has been found and will be added")
        endif()
    endforeach()

    file(REMOVE_RECURSE "${CMAKE_SOURCE_DIR}/fakeqml")
    message(STATUS "deleted fakeqml folder, this will be regenerated during CMake configuration as it is required for packaging the application properly")
endmacro()

macro(BuildLah_add_component arg_target_name arg_target_type arg_files_path arg_build_define arg_use_define arg_qrc_prefix)
    if(${arg_target_type} STREQUAL "GUI")
        qt6_add_executable(${arg_target_name} WIN32 MACOSX_BUNDLE MANUAL_FINALIZATION)
        message(STATUS "added ${arg_target_name} as normal application")
    elseif(${arg_target_type} STREQUAL "CLI")
        qt6_add_executable(${arg_target_name} MANUAL_FINALIZATION)
        message(STATUS "added ${arg_target_name} as command line application")
    elseif(${arg_target_type} STREQUAL "DLL")
        qt6_add_library(${arg_target_name} SHARED MANUAL_FINALIZATION)
        message(STATUS "added ${arg_target_name} as shared library")
    else()
        message(FATAL_ERROR "${arg_target_type} is NOT a valid type and cannot be used as the type of ${arg_target_name}, pls choose between GUI for normal apps, CLI for command line apps, and DLL for shared libraries")
    endif()

    if(NOT ${arg_build_define} STREQUAL "")
        target_compile_definitions(${arg_target_name} PRIVATE ${arg_build_define})
        message(STATUS "when building ${arg_target_name}, the preprocessor will define ${arg_build_define}")
    endif()
    if(NOT ${arg_use_define} STREQUAL "")
        target_compile_definitions(${arg_target_name} PUBLIC ${arg_use_define})
        message(STATUS "when building or using ${arg_target_name}, the preprocessor will define ${arg_use_define}")
    endif()

    if(NOT IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${arg_files_path}")
        message(FATAL_ERROR "there is no folder at ${arg_files_path} which resolves to ${CMAKE_CURRENT_SOURCE_DIR}/${arg_files_path} so it cannot be used to create ${arg_target_name}, pls ensure that the folder you specify exists and that its path consists of only alphanumeric characters and underscores")
    endif()

    target_include_directories(${arg_target_name} PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/dll_defines>")
    message(STATUS "added dll_defines to include paths of ${arg_target_name}, this allows access to shared library access specifier preprocessor macros")
    target_include_directories(${arg_target_name} PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/${arg_files_path}/include>")
    message(STATUS "added ${arg_files_path}/include to include paths of ${arg_target_name}, this allows access to header files")
    target_include_directories(${arg_target_name} PUBLIC "$<INSTALL_INTERFACE:include/dll_defines>")
    target_include_directories(${arg_target_name} PUBLIC "$<INSTALL_INTERFACE:include/${arg_files_path}/include>")

    file(GLOB_RECURSE ASSETS_FILES_ABSOLUTE CONFIGURE_DEPENDS "${arg_files_path}/assets/*")
    list(TRANSFORM ASSETS_FILES_ABSOLUTE REPLACE "^${CMAKE_CURRENT_SOURCE_DIR}/" "" OUTPUT_VARIABLE ASSETS_FILES)
    qt6_add_resources(${arg_target_name} ${arg_target_name}_assets PREFIX "${arg_qrc_prefix}" BASE "${arg_files_path}/assets" FILES ${ASSETS_FILES})
    list(TRANSFORM ASSETS_FILES REPLACE "^${arg_files_path}/assets/" "" OUTPUT_VARIABLE ASSETS_FILES_NAMEONLY)
    foreach(asset_file ${ASSETS_FILES_NAMEONLY})
        message(STATUS "added ${arg_files_path}/assets/${asset_file} to Qt Resource System of ${arg_target_name} as :/${arg_qrc_prefix}/${asset_file}")
    endforeach()

    file(GLOB_RECURSE SHADERS_FILES_ABSOLUTE CONFIGURE_DEPENDS "${arg_files_path}/shaders/*")
    list(TRANSFORM SHADERS_FILES_ABSOLUTE REPLACE "^${CMAKE_CURRENT_SOURCE_DIR}/" "" OUTPUT_VARIABLE SHADERS_FILES)
    qt6_add_shaders(${arg_target_name} ${arg_target_name}_shaders PREFIX "${arg_qrc_prefix}" BASE "${arg_files_path}/shaders" FILES ${SHADERS_FILES})
    list(TRANSFORM SHADERS_FILES REPLACE "^${arg_files_path}/shaders/" "" OUTPUT_VARIABLE SHADERS_FILES_NAMEONLY)
    foreach(shader_file ${SHADERS_FILES_NAMEONLY})
        message(STATUS "the shader at ${arg_files_path}/shaders/${shader_file} has been compiled using QSB and added to Qt Resource System of ${arg_target_name} as :/${arg_qrc_prefix}/${shader_file}.qsb")
    endforeach()

    file(GLOB_RECURSE SOURCE_FILES_ABSOLUTE CONFIGURE_DEPENDS "${arg_files_path}/src/*")
    list(TRANSFORM SOURCE_FILES_ABSOLUTE REPLACE "^${CMAKE_CURRENT_SOURCE_DIR}/" "" OUTPUT_VARIABLE SOURCE_FILES)
    if(${arg_target_name} STREQUAL "SG_Widgets")
        list(APPEND SOURCE_FILES SG_Widgets/include/private_api_Widgets/SGXQuickResizer.h SG_Widgets/include/private_api_Widgets/SGXThemeColourSetting.h SG_Widgets/include/private_api_Widgets/SGXSingCorrectQuickInterface.h)
    endif()
    target_sources(${arg_target_name} PRIVATE ${SOURCE_FILES})
    foreach(source_file ${SOURCE_FILES})
        message(STATUS "source file ${source_file} has been added to ${arg_target_name}")
    endforeach()

    set(LIBRARIES_TO_LINK ${ARGN})
    foreach(library ${LIBRARIES_TO_LINK})
        if(TARGET ${library})
            target_link_libraries(${arg_target_name} PUBLIC ${library})
            message(STATUS "linked ${arg_target_name} to shared library ${library}")
        else()
            message(FATAL_ERROR "${library} is not a shared library so ${arg_target_name} cannot link to it")
        endif()
    endforeach()

    cmake_policy(SET CMP0057 NEW)
    set(link_SGWidgets OFF)
    if("SGEXTN::SG_Widgets" IN_LIST LIBRARIES_TO_LINK)
        set(link_SGWidgets TRUE)
    elseif("SG_Widgets" IN_LIST LIBRARIES_TO_LINK)
        set(link_SGWidgets TRUE)
    elseif(${arg_target_name} STREQUAL "SG_Widgets")
        set(link_SGWidgets TRUE)
    endif()
    if(link_SGWidgets)
        qt6_policy(SET QTP0001 NEW)
        qt6_policy(SET QTP0004 NEW)
        file(WRITE ${CMAKE_SOURCE_DIR}/fakeqml/${arg_target_name}.qml "import QtQuick\nimport QtQuick.Controls\nimport QtQuick.Dialogs\nimport QtQuick.Window\nItem{}")
        file(APPEND ${CMAKE_SOURCE_DIR}/fakeqml/qmldir "${arg_target_name} 0.0 ${arg_target_name}.qml\n")
        qt6_add_qml_module(${arg_target_name} URI ${arg_target_name}_fakeqml OUTPUT_DIRECTORY ${arg_target_name}_fakeqml IMPORTS QtQuick QtQuick.Controls QtQuick.Dialogs QtQuick.Window QML_FILES fakeqml/${arg_target_name}.qml)
        message(STATUS "${arg_target_name} uses SGWidgets and relevant QML have been set up")
    endif()

    set(EXCLUDE_PLUGINS designer help printsupport qmllint qmlls qmltooling sqldrivers)
    file(GLOB PLUGIN_TYPE_FOLDERS "${Qt6_DIR}/plugins/*")
    set(QT_PLUGIN_NAMES "")
    foreach(TYPE_FOLDER ${PLUGIN_TYPE_FOLDERS})
        get_filename_component(TYPE_NAME ${TYPE_FOLDER} NAME)
        if(NOT TYPE_NAME IN_LIST EXCLUDE_PLUGINS)
            list(APPEND QT_PLUGIN_NAMES ${TYPE_NAME})
        endif()
    endforeach()
    qt6_import_plugins(${arg_target_name} INCLUDE_BY_TYPE ${QT_PLUGIN_NAMES} EXCLUDE_BY_TYPE ${EXCLUDE_PLUGINS})

    qt6_finalize_target(${arg_target_name})
    message(STATUS "${arg_target_name} has been successfully set up")
endmacro()
