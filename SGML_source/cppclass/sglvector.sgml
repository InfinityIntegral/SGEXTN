@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_TITLE SGLVector
@SG_ML_BLANKLINE
@SG_ML_L0F56see header filehttps://github.com/InfinityIntegral/SGEXTN/tree/main/SG_Containers/include/SGLVector.h
(no source file, everything inside header)
@SG_ML_BLANKLINE
template <typename T> class SGLVector;
part of SGEXTN module @SG_ML_L0D18SG_Containers../modules/sg_containers
resizable array for any type of data
@SG_ML_L1417detailed description#sg_detaileddescription
@SG_ML_L2715list of all including inherited members../funclist/sglvector
@SG_ML_L1619implementation details#sg_implementationdetails
@SG_ML_BLANKLINE
preprocessor file inclusion directive: #include<SGLVector.h>
CMake commands:
&#9;find_package(@SG_ML_L0609SGEXTN../readme REQUIRED COMPONENTS @SG_ML_L0D18SG_Containers../modules/sg_containers)
&#9;target_link_libraries(yourCMakeTarget PRIVATE @SG_ML_L1518SGEXTN::SG_Containers../modules/sg_containers)
parent class: (none)
children classes: (none)
@SG_ML_BLANKLINE
@SG_ML_HEADER_ instance member functions
&#9;@SG_ML_L091BSGLVector#SGLVector_int_const_T_ref_(int count, const T& defaultValue);
&#9;@SG_ML_L090FSGLVector#SGLVector_int_(int count);
&#9;@SG_ML_L0910SGLVector#SGLVector_func_();
&#9;void @SG_ML_L061Dassign#void_assign_int_const_T_ref_(int count, const T& defaultValue);
&#9;[[nodiscard]] const T& @SG_ML_L0224at#nodiscard_const_T_ref_at_int_const_(int i) const;
&#9;[[nodiscard]] T& @SG_ML_L0218at#nodiscard_T_ref_at_int_(int i);
&#9;[[nodiscard]] const T& @SG_ML_L0427back#nodiscard_const_T_ref_back_func_const_() const;
&#9;void @SG_ML_L0417fill#void_fill_const_T_ref_(const T& defaultValue);
&#9;[[nodiscard]] int @SG_ML_L0621length#nodiscard_int_length_func_const_() const;
&#9;[[nodiscard]] const T* @SG_ML_L0D2FpointerToData#nodiscard_const_T_ptr_pointerToData_int_const_(int n) const;
&#9;[[nodiscard]] T* @SG_ML_L0D23pointerToData#nodiscard_T_ptr_pointerToData_int_(int n);
&#9;void @SG_ML_L0713popBack#void_popBack_func_();
&#9;void @SG_ML_L081BpushBack#void_pushBack_const_T_ref_(const T& x);
&#9;void @SG_ML_L0712reserve#void_reserve_int_(int newMemoryLength);
@SG_ML_BLANKLINE
@SG_ML_HEADER_detaileddescription Detailed Description
@SG_ML_L0909SGLVectorsglvector provides a template based vector (resizable array) that works with any data type. This is a template based class with no separate source file. This class is a SGEXTN container. Copy constructor, copy assignment, move constructor, move assignment, and destructor work as expected. A deep copy is performed whenever this class is copied, and the new instance will not be linked to the old instance in any way. It is assumed that the contents placed into this SGEXTN container can be copied and moved. This means that their copy constructor copy assignment, move constructor, move assignment, and destructor work as expected. If this is not the case or if you want the container to store references or constant references, store pointers instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_implementationdetails Implementation Details
@SG_ML_L0808SGLDequesgldeque internally stores a buffer in the form of a C array. When the buffer is full and more elements need to be appended, the buffer doubles in size.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLVector_int_const_T_ref_ @SG_ML_L091BSGLVector#SGLVector_int_const_T_ref_(int count, const T& defaultValue);
Creates a @SG_ML_L0909SGLVectorsglvector of size @SG_ML_B05count with every element set to @SG_ML_B0CdefaultValue.
@SG_ML_WARN Negative @SG_ML_B05count is @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLVector_int_ @SG_ML_L090FSGLVector#SGLVector_int_(int count);
Creates a @SG_ML_L0909SGLVectorsglvector of size @SG_ML_B05count with every element default initialised.
@SG_ML_WARN This will not compile if the data in the @SG_ML_L0909SGLVectorsglvector do not have a default constructor (the one taking no arguments).
@SG_ML_WARN Negative @SG_ML_B05count is @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLVector_func_ @SG_ML_L0910SGLVector#SGLVector_func_();
Creates an empty @SG_ML_L0909SGLVectorsglvector.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_assign_int_const_T_ref_ void @SG_ML_L061Dassign#void_assign_int_const_T_ref_(int count, const T& defaultValue);
Assigns a @SG_ML_L0909SGLVectorsglvector(@SG_ML_B05count, @SG_ML_B0CdefaultValue) to this @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE v.assign(@SG_ML_B05count, @SG_ML_B0CdefaultValue); is identical in functionality to v = @SG_ML_L0909SGLVectorsglvector<T>(@SG_ML_B05count, @SG_ML_B0CdefaultValue); Choosing one over the other is purely coding style.
@SG_ML_WARN Negative @SG_ML_B05count is @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_at_int_const_ [[nodiscard]] const T& @SG_ML_L0224at#nodiscard_const_T_ref_at_int_const_(int i) const;
Returns a constant reference to element @SG_ML_B01i of the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_WARN This crashes for out of bounds @SG_ML_B01i.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_T_ref_at_int_ [[nodiscard]] T& @SG_ML_L0218at#nodiscard_T_ref_at_int_(int i);
Returns a reference to element @SG_ML_B01i of the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_WARN This crashes for out of bounds @SG_ML_B01i.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_back_func_const_ [[nodiscard]] const T& @SG_ML_L0427back#nodiscard_const_T_ref_back_func_const_() const;
Returns a constant reference to the last element of the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE v.back() has the same effect as v.at(v.length() - 1)
@SG_ML_NOTE Use @SG_ML_L0D2DSGLVector::atsglvector#nodiscard_const_T_ref_at_int_const_@SG_ML_L0D21SGLVector::atsglvector#nodiscard_T_ref_at_int_ if the element needs to be modified.
@SG_ML_WARN This crashes if the @SG_ML_L0909SGLVectorsglvector is empty.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_fill_const_T_ref_ void @SG_ML_L0417fill#void_fill_const_T_ref_(const T& defaultValue);
Sets every element in the existing @SG_ML_L0909SGLVectorsglvector to @SG_ML_B0CdefaultValue without resizing the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE If the @SG_ML_L0909SGLVectorsglvector may need to be resized, use @SG_ML_L1126SGLVector::assignsglvector#void_assign_int_const_T_ref_ instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_length_func_const_ [[nodiscard]] int @SG_ML_L0621length#nodiscard_int_length_func_const_() const;
Returns the length of the @SG_ML_L0909SGLVectorsglvector, which is the number of elements currently stored in it.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ptr_pointerToData_int_const_ [[nodiscard]] const T* @SG_ML_L0D2FpointerToData#nodiscard_const_T_ptr_pointerToData_int_const_(int n) const;
Returns a read only pointer to element @SG_ML_B01n of the @SG_ML_L0909SGLVectorsglvector. This does not dereference the returned pointer.
@SG_ML_NOTE Using an out of bounds value for @SG_ML_B01n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for @SG_ML_B01n may be used intentionally to specify parts of the @SG_ML_L0909SGLVectorsglvector to run @SG_ML_L0707SGLSortsglsort on.
@SG_ML_NOTE The returned value may function as an iterator.
@SG_ML_WARN Dereferencing the returned pointer when @SG_ML_B01n is out of bounds results in @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_T_ptr_pointerToData_int_ [[nodiscard]] T* @SG_ML_L0D23pointerToData#nodiscard_T_ptr_pointerToData_int_(int n);
Returns a pointer to element @SG_ML_B01n of the @SG_ML_L0909SGLVectorsglvector. This does not dereference the returned pointer.
@SG_ML_NOTE Using an out of bounds value for @SG_ML_B01n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for @SG_ML_B01n may be used intentionally to specify parts of the @SG_ML_L0909SGLVectorsglvector to run @SG_ML_L0707SGLSortsglsort on.
@SG_ML_NOTE The returned value may function as an iterator.
@SG_ML_NOTE Assigning to the dereferenced value from the returned pointer would modify the @SG_ML_L0808SGLArraysglarray
@SG_ML_WARN Dereferencing the returned pointer when @SG_ML_B01n is out of bounds results in @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_popBack_func_ void @SG_ML_L0713popBack#void_popBack_func_();
Removes the last element of the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE This does not return the removed element. Use @SG_ML_L0F30SGLVector::backsglvector#nodiscard_const_T_ref_back_func_const_ before removal to access the element.
@SG_ML_NOTE This runs at true constant time complexity.
@SG_ML_WARN Removing from empty @SG_ML_L0909SGLVectorsglvector is @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_pushBack_const_T_ref_ void @SG_ML_L081BpushBack#void_pushBack_const_T_ref_(const T& x);
Appends @SG_ML_B01x to the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE This runs at amortised constant time complexity. To make it truly constant time, pre allocate the memory needed using @SG_ML_L121BSGLVector::reservesglvector#void_reserve_int_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_reserve_int_ void @SG_ML_L0712reserve#void_reserve_int_(int newMemoryLength);
Pre allocates enough memory in the buffer to store @SG_ML_B0FnewMemoryLength elements in the @SG_ML_L0909SGLVectorsglvector.
@SG_ML_NOTE If there is already sufficient memory to store @SG_ML_B0FnewMemoryLength elements, this is ignored.
@SG_ML_BLANKLINE
