@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME SGLArray Documentation
@SG_ML_TITLE SGLArray
@SG_ML_BLANKLINE
@SG_ML_L00F055see header filehttps://github.com/InfinityIntegral/SGEXTN/tree/main/SG_Containers/include/SGLArray.h
(no source file, everything inside header)
@SG_ML_BLANKLINE
template ‹typename T› class SGLArray;
part of SGEXTN module @SG_ML_L00D018SG_Containers../modules/sg_containers
variable length array for any type of data
@SG_ML_L014017detailed description#sg_detaileddescription
@SG_ML_L027014list of all including inherited members../funclist/sglarray
@SG_ML_L016019implementation details#sg_implementationdetails
@SG_ML_BLANKLINE
preprocessor file inclusion directive: #include ‹SGLArray.h›
CMake target for BuildLah: @SG_ML_L015018SGEXTN::SG_Containers../modules/sg_containers
see @SG_ML_L009015this link../tutorials/buildlah for more information about BuildLah
parent class: (none)
children classes: (none)
@SG_ML_BLANKLINE
@SG_ML_HEADER_ instance member functions
&#9;@SG_ML_L00801ASGLArray#SGLArray_int_const_T_ref_(int count, const T& defaultValue);
&#9;@SG_ML_L00800DSGLArray#SGLArray_Ts_(Ts... data);
&#9;@SG_ML_L00800ESGLArray#SGLArray_int_(int count);
&#9;void @SG_ML_L00601Dassign#void_assign_int_const_T_ref_(int count, const T& defaultValue);
&#9;[[nodiscard]] const T& @SG_ML_L002024at#nodiscard_const_T_ref_at_int_const_(int i) const;
&#9;[[nodiscard]] T& @SG_ML_L002018at#nodiscard_T_ref_at_int_(int i);
&#9;void @SG_ML_L004017fill#void_fill_const_T_ref_(const T& defaultValue);
&#9;[[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
&#9;[[nodiscard]] const T* @SG_ML_L00D02FpointerToData#nodiscard_const_T_ptr_pointerToData_int_const_(int n) const;
&#9;[[nodiscard]] T* @SG_ML_L00D023pointerToData#nodiscard_T_ptr_pointerToData_int_(int n);
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_detaileddescription Detailed Description
@SG_ML_L008014SGLArray../cppclass/sglarray provides a template based array data structure to store any type of data. This is similar to C arrays and different from C++'s std::array as the size does not need to be a compile time constant. This is a template based class with no separate source file. This class is a SGEXTN container. Copy constructor, copy assignment, move constructor, move assignment, and destructor work as expected. A deep copy is performed whenever this class is copied, and the new instance will not be linked to the old instance in any way. It is assumed that the contents placed into this SGEXTN container can be copied and moved. This means that their copy constructor copy assignment, move constructor, move assignment, and destructor work as expected. If this is not the case or if you want the container to store references or constant references, store pointers instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_implementationdetails Implementation Details
@SG_ML_L008014SGLArray../cppclass/sglarray internally maintains a C array stored on the heap.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLArray_int_const_T_ref_ @SG_ML_L00801ASGLArray#SGLArray_int_const_T_ref_(int count, const T& defaultValue);
Creates a @SG_ML_L008014SGLArray../cppclass/sglarray of size @SG_ML_B005count, with every element initialised to @SG_ML_B00CdefaultValue.
@SG_ML_WARN You must ensure that @SG_ML_B005count is nonnegative. Negative @SG_ML_B005count will crash.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLArray_Ts_ @SG_ML_L00800DSGLArray#SGLArray_Ts_(Ts... data);
@SG_ML_L008014SGLArray../cppclass/sglarray does not support initialisation using initialiser lists. This is the closest that you can get to using a initialiser list.
This constructor of @SG_ML_L008014SGLArray../cppclass/sglarray takes a variable number of arguments corresponding to what the data inside should be set to. The length of the @SG_ML_L008014SGLArray../cppclass/sglarray is determined automatically from the number of arguments passed.
The produced @SG_ML_L008014SGLArray../cppclass/sglarray will contain all the arguments passed in order to the variadic template @SG_ML_B004data, for example @SG_ML_L008014SGLArray../cppclass/sglarray‹int›(1, 2, 3, 4, 5) will create a @SG_ML_L008014SGLArray../cppclass/sglarray‹int› with contents [1, 2, 3, 4, 5]
@SG_ML_NOTE The arguments to this constructor must be within a pair of parentheses, not braces. This is NOT a initialiser list.
@SG_ML_WARN This constructor has lower function overload resolution priority than any other constructor. When using this to initialise a @SG_ML_L008014SGLArray../cppclass/sglarray containing 1 or 2 numerical data types, ensure that this does not resolve to another constructor unintentionally.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLArray_int_ @SG_ML_L00800ESGLArray#SGLArray_int_(int count);
Creates a @SG_ML_L008014SGLArray../cppclass/sglarray of size @SG_ML_B005count, with every element default initialised.
@SG_ML_WARN The type stored in the @SG_ML_L008014SGLArray../cppclass/sglarray must have a default constructor (the one taking no arguments) for this to compile.
@SG_ML_WARN You must ensure that @SG_ML_B005count is nonnegative. Negative @SG_ML_B005count will crash.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_assign_int_const_T_ref_ void @SG_ML_L00601Dassign#void_assign_int_const_T_ref_(int count, const T& defaultValue);
Assigns a @SG_ML_L008014SGLArray../cppclass/sglarray(@SG_ML_B005count, @SG_ML_B00CdefaultValue) to this @SG_ML_L008014SGLArray../cppclass/sglarray.
@SG_ML_NOTE arr.assign(@SG_ML_B005count, @SG_ML_B00CdefaultValue); is identical in functionality to arr = @SG_ML_L008014SGLArray../cppclass/sglarray‹T›(@SG_ML_B005count, @SG_ML_B00CdefaultValue); Choosing one over the other is purely coding style.
@SG_ML_WARN You must ensure that @SG_ML_B005count is nonnegative. Negative @SG_ML_B005count will crash.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_at_int_const_ [[nodiscard]] const T& @SG_ML_L002024at#nodiscard_const_T_ref_at_int_const_(int i) const;
Returns a constant reference to element @SG_ML_B001i of the @SG_ML_L008014SGLArray../cppclass/sglarray.
@SG_ML_WARN This will crash for out of bounds @SG_ML_B001i.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_T_ref_at_int_ [[nodiscard]] T& @SG_ML_L002018at#nodiscard_T_ref_at_int_(int i);
Returns a reference to element @SG_ML_B001i of the @SG_ML_L008014SGLArray../cppclass/sglarray.
@SG_ML_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the @SG_ML_L008014SGLArray../cppclass/sglarray.
@SG_ML_WARN This will crash for out of bounds @SG_ML_B001i.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_fill_const_T_ref_ void @SG_ML_L004017fill#void_fill_const_T_ref_(const T& defaultValue);
Sets every element in the existing @SG_ML_L008014SGLArray../cppclass/sglarray to @SG_ML_B00CdefaultValue without resizing the @SG_ML_L008014SGLArray../cppclass/sglarray.
@SG_ML_NOTE If the @SG_ML_L008014SGLArray../cppclass/sglarray may need to be resized, use @SG_ML_L010031SGLArray::assign../cppclass/sglarray#void_assign_int_const_T_ref_ instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_length_func_const_ [[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
Returns the length of the @SG_ML_L008014SGLArray../cppclass/sglarray, which is the number of elements stored inside it.
@SG_ML_NOTE Unless assigned to or if @SG_ML_L010031SGLArray::assign../cppclass/sglarray#void_assign_int_const_T_ref_ is used, this always stays the same after the @SG_ML_L008014SGLArray../cppclass/sglarray is created.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ptr_pointerToData_int_const_ [[nodiscard]] const T* @SG_ML_L00D02FpointerToData#nodiscard_const_T_ptr_pointerToData_int_const_(int n) const;
Returns a read only pointer to element @SG_ML_B001n of the @SG_ML_L008014SGLArray../cppclass/sglarray. This does not dereference the returned pointer.
@SG_ML_NOTE Using an out of bounds value for @SG_ML_B001n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for @SG_ML_B001n may be used intentionally to specify parts of the @SG_ML_L008014SGLArray../cppclass/sglarray to run @SG_ML_L007013SGLSort../cppclass/sglsort on.
@SG_ML_NOTE The returned value may function as an iterator.
@SG_ML_WARN Dereferencing the returned pointer when @SG_ML_B001n is out of bounds results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_T_ptr_pointerToData_int_ [[nodiscard]] T* @SG_ML_L00D023pointerToData#nodiscard_T_ptr_pointerToData_int_(int n);
Returns a pointer to element @SG_ML_B001n of the @SG_ML_L008014SGLArray../cppclass/sglarray. This does not dereference the returned pointer.
@SG_ML_NOTE Using an out of bounds value for @SG_ML_B001n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for @SG_ML_B001n may be used intentionally to specify parts of the @SG_ML_L008014SGLArray../cppclass/sglarray to run @SG_ML_L007013SGLSort../cppclass/sglsort on.
@SG_ML_NOTE The returned value may function as an iterator.
@SG_ML_NOTE Assigning to the dereferenced value from the returned pointer would modify the @SG_ML_L008014SGLArray../cppclass/sglarray
@SG_ML_WARN Dereferencing the returned pointer when @SG_ML_B001n is out of bounds results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
