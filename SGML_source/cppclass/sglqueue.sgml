@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME SGLQueue Documentation
@SG_ML_TITLE SGLQueue
@SG_ML_BLANKLINE
@SG_ML_L00F055see header filehttps://github.com/InfinityIntegral/SGEXTN/tree/main/SG_Containers/include/SGLQueue.h
(no source file, everything inside header)
@SG_ML_BLANKLINE
template ‹typename T› class SGLQueue;
part of SGEXTN module @SG_ML_L00D018SG_Containers../modules/sg_containers
queue for any type of data
@SG_ML_L014017detailed description#sg_detaileddescription
@SG_ML_L027014list of all including inherited members../funclist/sglqueue
@SG_ML_L016019implementation details#sg_implementationdetails
@SG_ML_BLANKLINE
preprocessor file inclusion directive: #include ‹SGLQueue.h›
CMake target for BuildLah: @SG_ML_L015018SGEXTN::SG_Containers../modules/sg_containers
see @SG_ML_L009015this link../tutorials/buildlah for more information about BuildLah
parent class: (none)
children classes: (none)
@SG_ML_BLANKLINE
@SG_ML_HEADER_ instance member functions
&#9;@SG_ML_L00800FSGLQueue#SGLQueue_func_();
&#9;[[nodiscard]] const T& @SG_ML_L004027back#nodiscard_const_T_ref_back_func_const_() const;
&#9;[[nodiscard]] const T& @SG_ML_L005028front#nodiscard_const_T_ref_front_func_const_() const;
&#9;[[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
&#9;void @SG_ML_L00300Fpop#void_pop_func_();
&#9;void @SG_ML_L004017push#void_push_const_T_ref_(const T& x);
&#9;void @SG_ML_L007012reserve#void_reserve_int_(int newMemoryLength);
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_detaileddescription Detailed Description
@SG_ML_L008014SGLQueue../cppclass/sglqueue provides a template based queue for any data type. This is a template based class with no separate source file. This class is a SGEXTN container. Copy constructor, copy assignment, move constructor, move assignment, and destructor work as expected. A deep copy is performed whenever this class is copied, and the new instance will not be linked to the old instance in any way. It is assumed that the contents placed into this SGEXTN container can be copied and moved. This means that their copy constructor copy assignment, move constructor, move assignment, and destructor work as expected. If this is not the case or if you want the container to store references or constant references, store pointers instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_implementationdetails Implementation Details
@SG_ML_L008014SGLQueue../cppclass/sglqueue internally stores a buffer in the form of a C array. When no more elements can be appended into the buffer, it resizes to double its previous size and aligns all elements to the front of the queue.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLQueue_func_ @SG_ML_L00800FSGLQueue#SGLQueue_func_();
Creates an empty @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_back_func_const_ [[nodiscard]] const T& @SG_ML_L004027back#nodiscard_const_T_ref_back_func_const_() const;
Returns the element at the back of the @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_WARN This is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour if the @SG_ML_L008014SGLQueue../cppclass/sglqueue is empty.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_front_func_const_ [[nodiscard]] const T& @SG_ML_L005028front#nodiscard_const_T_ref_front_func_const_() const;
Returns the element at the front of the @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_WARN This is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour if the @SG_ML_L008014SGLQueue../cppclass/sglqueue is empty.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_length_func_const_ [[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
Returns the length of the @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_pop_func_ void @SG_ML_L00300Fpop#void_pop_func_();
Removes the front element of the @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_NOTE This has truly constant time complexity.
@SG_ML_NOTE This does not return the removed element. To access the removed element, use @SG_ML_L00F03CSGLQueue::front../cppclass/sglqueue#nodiscard_const_T_ref_front_func_const_ before removal.
@SG_ML_WARN This is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour if the @SG_ML_L008014SGLQueue../cppclass/sglqueue is empty.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_push_const_T_ref_ void @SG_ML_L004017push#void_push_const_T_ref_(const T& x);
Appends @SG_ML_B001x at the back of the @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_NOTE This has a amortised constant time complexity. To achieve true constant time complexity, pre allocate memory equal to the amount you need using @SG_ML_L011026SGLQueue::reserve../cppclass/sglqueue#void_reserve_int_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_reserve_int_ void @SG_ML_L007012reserve#void_reserve_int_(int newMemoryLength);
Pre allocates sufficient memory to store @SG_ML_B00FnewMemoryLength elements in the @SG_ML_L008014SGLQueue../cppclass/sglqueue.
@SG_ML_NOTE If there is already sufficient memory to store @SG_ML_B00FnewMemoryLength elements, this is ignored.
@SG_ML_BLANKLINE
