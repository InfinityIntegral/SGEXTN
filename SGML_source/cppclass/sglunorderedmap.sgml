@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME SGLUnorderedMap Documentation
@SG_ML_TITLE SGLUnorderedMap
@SG_ML_BLANKLINE
@SG_ML_L00F05Csee header filehttps://github.com/InfinityIntegral/SGEXTN/tree/main/SG_Containers/include/SGLUnorderedMap.h
(no source file, everything inside header)
@SG_ML_BLANKLINE
template ‹typename K, typename V, typename EqualityCheck, typename HashFunction› class SGLUnorderedMap;
part of SGEXTN module @SG_ML_L00D018SG_Containers../modules/sg_containers
unordered map for any type of data
@SG_ML_L014017detailed description#sg_detaileddescription
@SG_ML_L02701Blist of all including inherited members../funclist/sglunorderedmap
@SG_ML_L016019implementation details#sg_implementationdetails
@SG_ML_BLANKLINE
preprocessor file inclusion directive: #include ‹SGLUnorderedMap.h›
CMake commands:
&#9;find_package(@SG_ML_L006010SGEXTN../readme/readme REQUIRED COMPONENTS @SG_ML_L00D018SG_Containers../modules/sg_containers)
&#9;target_link_libraries(yourCMakeTarget PRIVATE @SG_ML_L015018SGEXTN::SG_Containers../modules/sg_containers)
parent class: (none)
children classes: (none)
@SG_ML_BLANKLINE
@SG_ML_HEADER_ instance member functions
&#9;@SG_ML_L00F016SGLUnorderedMap#SGLUnorderedMap_func_();
&#9;[[nodiscard]] V& @SG_ML_L002020at#nodiscard_V_ref_at_const_K_ref_(const K& x);
&#9;[[nodiscard]] const V& @SG_ML_L00202Cat#nodiscard_const_V_ref_at_const_K_ref_const_(const K &x) const;
&#9;[[nodiscard]] @SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator @SG_ML_L005032begin#nodiscard_SGLUnorderedMap_mc_Iterator_begin_func_();
&#9;[[nodiscard]] @SG_ML_L01E01ESGLUnorderedMap::ConstIteratorsglunorderedmap__constiterator @SG_ML_L00A042constBegin#nodiscard_SGLUnorderedMap_mc_ConstIterator_constBegin_func_const_() const;
&#9;[[nodiscard]] @SG_ML_L01E01ESGLUnorderedMap::ConstIteratorsglunorderedmap__constiterator @SG_ML_L008040constEnd#nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_() const;
&#9;[[nodiscard]] bool @SG_ML_L00802Bcontains#nodiscard_bool_contains_const_K_ref_const_(const K& x) const;
&#9;[[nodiscard]] int @SG_ML_L005027count#nodiscard_int_count_const_K_ref_const_(const K& x) const;
&#9;[[nodiscard]] @SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator @SG_ML_L003030end#nodiscard_SGLUnorderedMap_mc_Iterator_end_func_();
&#9;void @SG_ML_L005018erase#void_erase_const_K_ref_(const K& x);
&#9;void @SG_ML_L00502Cerase#void_erase_SGLUnorderedMap_mc_Iterator_ref_(@SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator& x);
&#9;[[nodiscard]] @SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator @SG_ML_L004038find#nodiscard_SGLUnorderedMap_mc_Iterator_find_const_K_ref_(const K& x);
&#9;[[nodiscard]] @SG_ML_L01E01ESGLUnorderedMap::ConstIteratorsglunorderedmap__constiterator @SG_ML_L004043find#nodiscard_SGLUnorderedMap_mc_ConstIterator_find_const_K_ref_const_(const K& x) const;
&#9;void @SG_ML_L006025insert#void_insert_const_K_ref_const_V_ref_(const K& xKey, const V& xValue);
&#9;[[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
&#9;void @SG_ML_L007012reserve#void_reserve_int_(int newMemoryLength);
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_detaileddescription Detailed Description
@SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap provides a template based unordered map that can be used with any data type. Use @SG_ML_L006012SGLMap../cppclass/sglmap instead if ordering matters. SGEXTN does not provide any unordered multimap so you must use a @SG_ML_L006012SGLMap../cppclass/sglmap‹K, @SG_ML_L009015SGLVector../cppclass/sglvector‹V››. This is a template based class with no separate source file. This class is a SGEXTN container. Copy constructor, copy assignment, move constructor, move assignment, and destructor work as expected. A deep copy is performed whenever this class is copied, and the new instance will not be linked to the old instance in any way. It is assumed that the contents placed into this SGEXTN container can be copied and moved. This means that their copy constructor copy assignment, move constructor, move assignment, and destructor work as expected. If this is not the case or if you want the container to store references or constant references, store pointers instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_implementationdetails Implementation Details
@SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap maintains an open addressed linear probing hash table with a load factor of 0.33 Due to the extremely low load factor, @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap is much faster than most implementations of unordered map (especially the Standard Template Library one, which is not even open addressed) at the cost of higher memory usage. The hash table is stored in a C array memory buffer that triples in size when the load factor is reached.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLUnorderedMap_func_ @SG_ML_L00F016SGLUnorderedMap#SGLUnorderedMap_func_();
Creates an empty @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_V_ref_at_const_K_ref_ [[nodiscard]] V& @SG_ML_L002020at#nodiscard_V_ref_at_const_K_ref_(const K& x);
Returns a reference to the value associated with key @SG_ML_B001x in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_WARN This crashes if @SG_ML_B001x is not in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap. Use @SG_ML_L019046SGLUnorderedMap::contains../cppclass/sglunorderedmap#nodiscard_bool_contains_const_K_ref_const_ to check if @SG_ML_B001x is in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap if unsure.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_V_ref_at_const_K_ref_const_ [[nodiscard]] const V& @SG_ML_L00202Cat#nodiscard_const_V_ref_at_const_K_ref_const_(const K &x) const;
Returns a constant reference to the value associated with key @SG_ML_B001x in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_WARN This crashes if @SG_ML_B001x is not in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap. Use @SG_ML_L019046SGLUnorderedMap::contains../cppclass/sglunorderedmap#nodiscard_bool_contains_const_K_ref_const_ to check if @SG_ML_B001x is in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap if unsure.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMap_mc_Iterator_begin_func_ [[nodiscard]] @SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator @SG_ML_L005032begin#nodiscard_SGLUnorderedMap_mc_Iterator_begin_func_();
Returns a iterator to the first key value pair in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_NOTE @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap iterators behave circularly. This is equivalent to running operator++ on @SG_ML_L01404BSGLUnorderedMap::end../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_Iterator_end_func_.
@SG_ML_NOTE @SG_ML_L019025SGLUnorderedMap::Iterator../cppclass/sglunorderedmap__iterator allows modifying the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap through it. If modification is not needed, use @SG_ML_L01E02ASGLUnorderedMap::ConstIterator../cppclass/sglunorderedmap__constiterator instead. The @SG_ML_L01E02ASGLUnorderedMap::ConstIterator../cppclass/sglunorderedmap__constiterator equivalent to this function is @SG_ML_L01B05DSGLUnorderedMap::constBegin../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_ConstIterator_constBegin_func_const_.
@SG_ML_WARN If the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap is empty, this is the same as @SG_ML_L01404BSGLUnorderedMap::end../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_Iterator_end_func_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMap_mc_ConstIterator_constBegin_func_const_ [[nodiscard]] @SG_ML_L01E01ESGLUnorderedMap::ConstIteratorsglunorderedmap__constiterator @SG_ML_L00A042constBegin#nodiscard_SGLUnorderedMap_mc_ConstIterator_constBegin_func_const_() const;
Returns a constant iterator to the first key value pair in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_NOTE @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap iterators behave circularly. This is equivalent to running operator++ on @SG_ML_L01905BSGLUnorderedMap::constEnd../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_.
@SG_ML_WARN If the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap is empty, this is the same as @SG_ML_L01905BSGLUnorderedMap::constEnd../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_ [[nodiscard]] @SG_ML_L01E01ESGLUnorderedMap::ConstIteratorsglunorderedmap__constiterator @SG_ML_L008040constEnd#nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_() const;
Returns a null constant iterator associated to this @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_NOTE @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap iterators behave circularly. This is equivalent to running operator-- on @SG_ML_L01B05DSGLUnorderedMap::constBegin../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_ConstIterator_constBegin_func_const_.
@SG_ML_WARN Attempting to access the key or value that this iterator points to is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_bool_contains_const_K_ref_const_ [[nodiscard]] bool @SG_ML_L00802Bcontains#nodiscard_bool_contains_const_K_ref_const_(const K& x) const;
Returns if the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap contains @SG_ML_B001x as a key
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_count_const_K_ref_const_ [[nodiscard]] int @SG_ML_L005027count#nodiscard_int_count_const_K_ref_const_(const K& x) const;
Returns the number of copies of the key @SG_ML_B001x is found inside the @SG_ML_L006012SGLMap../cppclass/sglmap.
@SG_ML_NOTE This is either 0 or 1, functionally identical to @SG_ML_L019046SGLUnorderedMap::contains../cppclass/sglunorderedmap#nodiscard_bool_contains_const_K_ref_const_. It is provided purely for API consistency.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMap_mc_Iterator_end_func_ [[nodiscard]] @SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator @SG_ML_L003030end#nodiscard_SGLUnorderedMap_mc_Iterator_end_func_();
Returns a null iterator associated to this @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_NOTE @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap iterators behave circularly. This is equivalent to running operator-- on @SG_ML_L01604DSGLUnorderedMap::begin../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_Iterator_begin_func_.
@SG_ML_NOTE @SG_ML_L019025SGLUnorderedMap::Iterator../cppclass/sglunorderedmap__iterator allows modifying the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap through it. If modification is not needed, use @SG_ML_L01E02ASGLUnorderedMap::ConstIterator../cppclass/sglunorderedmap__constiterator instead. The @SG_ML_L01E02ASGLUnorderedMap::ConstIterator../cppclass/sglunorderedmap__constiterator equivalent to this function is @SG_ML_L01905BSGLUnorderedMap::constEnd../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_.
@SG_ML_WARN Attempting to access the key or value that this iterator points to is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_erase_const_K_ref_ void @SG_ML_L005018erase#void_erase_const_K_ref_(const K& x);
Removes the key @SG_ML_B001x and its associated value from the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_WARN If @SG_ML_B001x is not in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap, this will crash. If you cannot guarantee that the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap already contains the key, use @SG_ML_L019046SGLUnorderedMap::contains../cppclass/sglunorderedmap#nodiscard_bool_contains_const_K_ref_const_ to check before removal. This is a intentional design choice to avoid silent bugs.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_erase_SGLUnorderedMap_mc_Iterator_ref_ void @SG_ML_L00502Cerase#void_erase_SGLUnorderedMap_mc_Iterator_ref_(@SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator& x);
Removes the key value pair associated with @SG_ML_B001x from the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
After the removal, @SG_ML_B001x which is passed as a reference, is decremented. This means that you do not have to do any special handling for removed elements when iterating over a @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_WARN Do not write any special logic to modify iterators while removing elements from a @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap in a loop, @SG_ML_L016033SGLUnorderedMap::erase../cppclass/sglunorderedmap#void_erase_const_K_ref_@SG_ML_L016047SGLUnorderedMap::erase../cppclass/sglunorderedmap#void_erase_SGLUnorderedMap_mc_Iterator_ref_ handles this for you automatically.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMap_mc_Iterator_find_const_K_ref_ [[nodiscard]] @SG_ML_L019019SGLUnorderedMap::Iteratorsglunorderedmap__iterator @SG_ML_L004038find#nodiscard_SGLUnorderedMap_mc_Iterator_find_const_K_ref_(const K& x);
Returns the iterator pointing to key @SG_ML_B001x.
@SG_ML_NOTE @SG_ML_L01404BSGLUnorderedMap::end../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_Iterator_end_func_ is returned if @SG_ML_B001x is not in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMap_mc_ConstIterator_find_const_K_ref_const_ [[nodiscard]] @SG_ML_L01E01ESGLUnorderedMap::ConstIteratorsglunorderedmap__constiterator @SG_ML_L004043find#nodiscard_SGLUnorderedMap_mc_ConstIterator_find_const_K_ref_const_(const K& x) const;
Returns the constant iterator pointing to key @SG_ML_B001x.
@SG_ML_NOTE @SG_ML_L01905BSGLUnorderedMap::constEnd../cppclass/sglunorderedmap#nodiscard_SGLUnorderedMap_mc_ConstIterator_constEnd_func_const_ is returned if @SG_ML_B001x is not in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_insert_const_K_ref_const_V_ref_ void @SG_ML_L006025insert#void_insert_const_K_ref_const_V_ref_(const K& xKey, const V& xValue);
Inserts the key value pair (@SG_ML_B004xKey, @SG_ML_B006xValue) into the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap.
@SG_ML_WARN If @SG_ML_B004xKey already exists in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap, this will crash. If you cannot guarantee that the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap does not already contain the key, use @SG_ML_L019046SGLUnorderedMap::contains../cppclass/sglunorderedmap#nodiscard_bool_contains_const_K_ref_const_ to check before insertion. This is a intentional design choice to avoid silent bugs.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_length_func_const_ [[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
Returns the length of the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap, which is the number of key value pairs currently stored inside it.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_reserve_int_ void @SG_ML_L007012reserve#void_reserve_int_(int newMemoryLength);
Pre allocates enough space for (@SG_ML_B00FnewMemoryLength / 3) - 1 elements to be stored in the @SG_ML_L00F01BSGLUnorderedMap../cppclass/sglunorderedmap without exceeding the load factor.
@SG_ML_NOTE If there is already sufficient memory allocated, this is ignored.
@SG_ML_BLANKLINE
