@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME SGLDeque Documentation
@SG_ML_TITLE SGLDeque
@SG_ML_BLANKLINE
@SG_ML_L00F055see header filehttps://github.com/InfinityIntegral/SGEXTN/tree/main/SG_Containers/include/SGLDeque.h
(no source file, everything inside header)
@SG_ML_BLANKLINE
template ‹typename T› class SGLDeque;
part of SGEXTN module @SG_ML_L00D018SG_Containers../modules/sg_containers
double ended queue for any type of data
@SG_ML_L014017detailed description#sg_detaileddescription
@SG_ML_L027014list of all including inherited members../funclist/sgldeque
@SG_ML_L016019implementation details#sg_implementationdetails
@SG_ML_BLANKLINE
preprocessor file inclusion directive: #include ‹SGLDeque.h›
CMake target for BuildLah: @SG_ML_L015018SGEXTN::SG_Containers../modules/sg_containers
see @SG_ML_L009015this link../tutorials/buildlah for more information about BuildLah
parent class: (none)
children classes: (none)
@SG_ML_BLANKLINE
@SG_ML_HEADER_ instance member functions
&#9;@SG_ML_L00800FSGLDeque#SGLDeque_func_();
&#9;@SG_ML_L00800ESGLDeque#SGLDeque_int_(int count);
&#9;@SG_ML_L00801ASGLDeque#SGLDeque_int_const_T_ref_(int count, const T& defaultValue);
&#9;void @SG_ML_L00601Dassign#void_assign_int_const_T_ref_(int count, const T& defaultValue);
&#9;[[nodiscard]] const T& @SG_ML_L002024at#nodiscard_const_T_ref_at_int_const_(int i) const;
&#9;[[nodiscard]] T& @SG_ML_L002018at#nodiscard_T_ref_at_int_(int i);
&#9;[[nodiscard]] const T& @SG_ML_L004027back#nodiscard_const_T_ref_back_func_const_() const;
&#9;void @SG_ML_L004017fill#void_fill_const_T_ref_(const T& defaultValue);
&#9;[[nodiscard]] const T& @SG_ML_L005028front#nodiscard_const_T_ref_front_func_const_() const;
&#9;[[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
&#9;[[nodiscard]] const T* @SG_ML_L00D02FpointerToData#nodiscard_const_T_ptr_pointerToData_int_const_(int n) const;
&#9;[[nodiscard]] T* @SG_ML_L00D023pointerToData#nodiscard_T_ptr_pointerToData_int_(int n);
&#9;void @SG_ML_L007013popBack#void_popBack_func_();
&#9;void @SG_ML_L008014popFront#void_popFront_func_();
&#9;void @SG_ML_L00801BpushBack#void_pushBack_const_T_ref_(const T& x);
&#9;void @SG_ML_L00901CpushFront#void_pushFront_const_T_ref_(const T& x);
&#9;void @SG_ML_L007012reserve#void_reserve_int_(int newMemoryLength);
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_detaileddescription Detailed Description
@SG_ML_L008014SGLDeque../cppclass/sgldeque provides a template based double queue, an array-like data structure that you can freely insert elements at and remove elements from both ends, in addition to randomly reading from and writing to elements by their index. If only queue or stack behaviour is needed, pls use @SG_ML_L008014SGLQueue../cppclass/sglqueue or @SG_ML_L008014SGLStack../cppclass/sglstack instead for better readability and performance. This is a template based class with no separate source file. This class is a SGEXTN container. Copy constructor, copy assignment, move constructor, move assignment, and destructor work as expected. A deep copy is performed whenever this class is copied, and the new instance will not be linked to the old instance in any way. It is assumed that the contents placed into this SGEXTN container can be copied and moved. This means that their copy constructor copy assignment, move constructor, move assignment, and destructor work as expected. If this is not the case or if you want the container to store references or constant references, store pointers instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_sg_implementationdetails Implementation Details
@SG_ML_L008014SGLDeque../cppclass/sgldeque internally stores a buffer in the form of a C array. Elements are placed into the buffer starting at approximately a third of the buffer's length and the start point and end point of the data is kept track of. Insertion at both ends expand the section of the buffer being used. If there is no more space for the buffer to expand, the buffer triples in size and all elements are shifted to align with the 1/3 mark.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLDeque_func_ @SG_ML_L00800FSGLDeque#SGLDeque_func_();
Creates a @SG_ML_L008014SGLDeque../cppclass/sgldeque containing no elements.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLDeque_int_ @SG_ML_L00800ESGLDeque#SGLDeque_int_(int count);
Creates a @SG_ML_L008014SGLDeque../cppclass/sgldeque containing @SG_ML_B005count elements which are default initialised.
@SG_ML_WARN The type stored in the @SG_ML_L008014SGLDeque../cppclass/sgldeque must have a default constructor (the one taking no arguments) for this to compile.
@SG_ML_WARN You must ensure that @SG_ML_B005count is nonnegative. Negative @SG_ML_B005count results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLDeque_int_const_T_ref_ @SG_ML_L00801ASGLDeque#SGLDeque_int_const_T_ref_(int count, const T& defaultValue);
Creates a @SG_ML_L008014SGLDeque../cppclass/sgldeque containing @SG_ML_B005count copies of @SG_ML_B00CdefaultValue.
@SG_ML_WARN You must ensure that @SG_ML_B005count is nonnegative. Negative @SG_ML_B005count results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_assign_int_const_T_ref_ void @SG_ML_L00601Dassign#void_assign_int_const_T_ref_(int count, const T& defaultValue);
Resets the @SG_ML_L008014SGLDeque../cppclass/sgldeque to have @SG_ML_B005count copies of @SG_ML_B00CdefaultValue.
dq.assign(@SG_ML_B005count, @SG_ML_B00CdefaultValue); is functionally identical to dq = @SG_ML_L008014SGLDeque../cppclass/sgldeque‹T›(@SG_ML_B005count, @SG_ML_B00CdefaultValue);
@SG_ML_WARN You must ensure that @SG_ML_B005count is nonnegative. Negative @SG_ML_B005count results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_at_int_const_ [[nodiscard]] const T& @SG_ML_L002024at#nodiscard_const_T_ref_at_int_const_(int i) const;
Returns a constant reference to element @SG_ML_B001i of the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_WARN This crashes for out of bounds @SG_ML_B001i.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_T_ref_at_int_ [[nodiscard]] T& @SG_ML_L002018at#nodiscard_T_ref_at_int_(int i);
Returns a reference to element @SG_ML_B001i of the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_WARN This crashes for out of bounds @SG_ML_B001i.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_back_func_const_ [[nodiscard]] const T& @SG_ML_L004027back#nodiscard_const_T_ref_back_func_const_() const;
Returns a constant reference to the last element of @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE dq.back() has the same effect as dq.at(dq.length() - 1)
@SG_ML_NOTE Use @SG_ML_L00C038SGLDeque::at../cppclass/sgldeque#nodiscard_const_T_ref_at_int_const_@SG_ML_L00C02CSGLDeque::at../cppclass/sgldeque#nodiscard_T_ref_at_int_ if the element needs to be modified.
@SG_ML_WARN If the @SG_ML_L008014SGLDeque../cppclass/sgldeque has a size of 0, accessing @SG_ML_L00E03BSGLDeque::back../cppclass/sgldeque#nodiscard_const_T_ref_back_func_const_ is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_fill_const_T_ref_ void @SG_ML_L004017fill#void_fill_const_T_ref_(const T& defaultValue);
Sets every element in the @SG_ML_L008014SGLDeque../cppclass/sgldeque to @SG_ML_B00CdefaultValue. This does not resize the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE If the @SG_ML_L008014SGLDeque../cppclass/sgldeque needs to be resized, use @SG_ML_L010031SGLDeque::assign../cppclass/sgldeque#void_assign_int_const_T_ref_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ref_front_func_const_ [[nodiscard]] const T& @SG_ML_L005028front#nodiscard_const_T_ref_front_func_const_() const;
Returns a constant reference to the first element of @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE dq.front() has the same effect as dq.at(0)
@SG_ML_NOTE Use @SG_ML_L00C038SGLDeque::at../cppclass/sgldeque#nodiscard_const_T_ref_at_int_const_@SG_ML_L00C02CSGLDeque::at../cppclass/sgldeque#nodiscard_T_ref_at_int_ if the element needs to be modified.
@SG_ML_WARN If the @SG_ML_L008014SGLDeque../cppclass/sgldeque has a size of 0, accessing @SG_ML_L00F03CSGLDeque::front../cppclass/sgldeque#nodiscard_const_T_ref_front_func_const_ is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_length_func_const_ [[nodiscard]] int @SG_ML_L006021length#nodiscard_int_length_func_const_() const;
Returns the length of the @SG_ML_L008014SGLDeque../cppclass/sgldeque, which is the number of elements currently stored inside it.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_const_T_ptr_pointerToData_int_const_ [[nodiscard]] const T* @SG_ML_L00D02FpointerToData#nodiscard_const_T_ptr_pointerToData_int_const_(int n) const;
Returns a read only pointer to element @SG_ML_B001n of the @SG_ML_L008014SGLDeque../cppclass/sgldeque. This does not dereference the returned pointer.
@SG_ML_NOTE Using an out of bounds value for @SG_ML_B001n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for @SG_ML_B001n may be used intentionally to specify parts of the @SG_ML_L008014SGLDeque../cppclass/sgldeque to run @SG_ML_L007013SGLSort../cppclass/sglsort on.
@SG_ML_NOTE The returned value may function as an iterator.
@SG_ML_WARN Dereferencing the returned pointer when @SG_ML_B001n is out of bounds results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_T_ptr_pointerToData_int_ [[nodiscard]] T* @SG_ML_L00D023pointerToData#nodiscard_T_ptr_pointerToData_int_(int n);
Returns a pointer to element @SG_ML_B001n of the @SG_ML_L008014SGLDeque../cppclass/sgldeque. This does not dereference the returned pointer.
@SG_ML_NOTE Using an out of bounds value for @SG_ML_B001n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for @SG_ML_B001n may be used intentionally to specify parts of the @SG_ML_L008014SGLDeque../cppclass/sgldeque to run @SG_ML_L007013SGLSort../cppclass/sglsort on.
@SG_ML_NOTE The returned value may function as an iterator.
@SG_ML_NOTE Assigning to the dereferenced value from the returned pointer would modify the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_WARN Dereferencing the returned pointer when @SG_ML_B001n is out of bounds results in @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_popBack_func_ void @SG_ML_L007013popBack#void_popBack_func_();
Removes the last element of the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE This runs in truly constant time.
@SG_ML_NOTE This does not return the last element. If you need the last element, access it with @SG_ML_L00E03BSGLDeque::back../cppclass/sgldeque#nodiscard_const_T_ref_back_func_const_ before running this.
@SG_ML_WARN Running @SG_ML_L011027SGLDeque::popBack../cppclass/sgldeque#void_popBack_func_ on an empty @SG_ML_L008014SGLDeque../cppclass/sgldeque is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_popFront_func_ void @SG_ML_L008014popFront#void_popFront_func_();
Removes the first element of the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE This runs in truly constant time.
@SG_ML_NOTE This does not return the first element. If you need the first element, access it with @SG_ML_L00F03CSGLDeque::front../cppclass/sgldeque#nodiscard_const_T_ref_front_func_const_ before running this.
@SG_ML_WARN Running @SG_ML_L012028SGLDeque::popFront../cppclass/sgldeque#void_popFront_func_ on an empty @SG_ML_L008014SGLDeque../cppclass/sgldeque is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_pushBack_const_T_ref_ void @SG_ML_L00801BpushBack#void_pushBack_const_T_ref_(const T& x);
Appends @SG_ML_B001x at the end of the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE This runs in amortised O(1) per use. To make it run in truly constant time, use @SG_ML_L011026SGLDeque::reserve../cppclass/sgldeque#void_reserve_int_ to pre allocate the internal memory buffer with 3 times the required memory.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_pushFront_const_T_ref_ void @SG_ML_L00901CpushFront#void_pushFront_const_T_ref_(const T& x);
Prepends @SG_ML_B001x at the start of the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE This runs in amortised O(1) per use. To make it run in truly constant time, use @SG_ML_L011026SGLDeque::reserve../cppclass/sgldeque#void_reserve_int_ to pre allocate the internal memory buffer with 3 times the required memory.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_reserve_int_ void @SG_ML_L007012reserve#void_reserve_int_(int newMemoryLength);
Pre allocates the internal memory buffer to a size sufficient to store @SG_ML_B00FnewMemoryLength elements in the @SG_ML_L008014SGLDeque../cppclass/sgldeque.
@SG_ML_NOTE Pre allocate 3 times the required memory to avoid resizing. This is only necessary for @SG_ML_L008014SGLDeque../cppclass/sgldeque and not @SG_ML_L009015SGLVector../cppclass/sglvector as only @SG_ML_L008014SGLDeque../cppclass/sgldeque permits insertion on both ends.
@SG_ML_NOTE If the internal memory buffer is larger than the requested length, nothing is done.
@SG_ML_BLANKLINE
