@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_TITLE SGLUnorderedMultiSet
@SG_ML_BLANKLINE
@SG_ML_L0F61see header filehttps://github.com/InfinityIntegral/SGEXTN/tree/main/SG_Containers/include/SGLUnorderedMultiSet.h
(no source file, everything inside header)
@SG_ML_BLANKLINE
template <typename T, typename EqualityCheck, typename HashFunction> class SGLUnorderedMultiSet;
part of SGEXTN module @SG_ML_L0D18SG_Containers../modules/sg_containers
unordered multiset for any type of data
@SG_ML_L1417detailed description#sg_detaileddescription
@SG_ML_L2720list of all including inherited members../funclist/sglunorderedmultiset
@SG_ML_L1619implementation details#sg_implementationdetails
@SG_ML_BLANKLINE
preprocessor file inclusion directive: #include<SGLUnorderedMultiSet.h>
CMake commands:
&#9;find_package(@SG_ML_L0609SGEXTN../readme REQUIRED COMPONENTS @SG_ML_L0D18SG_Containers../modules/sg_containers)
&#9;target_link_libraries(yourCMakeTarget PRIVATE @SG_ML_L1518SGEXTN::SG_Containers../modules/sg_containers)
parent class: (none)
children classes: (none)
@SG_ML_BLANKLINE
@SG_ML_HEADER_ instance member functions
&#9;@SG_ML_L141BSGLUnorderedMultiSet#SGLUnorderedMultiSet_func_();
&#9;[[nodiscard]] @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator @SG_ML_L0537begin#nodiscard_SGLUnorderedMultiSet_mc_Iterator_begin_func_();
&#9;[[nodiscard]] @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator @SG_ML_L0A47constBegin#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constBegin_func_const_() const;
&#9;[[nodiscard]] @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator @SG_ML_L0845constEnd#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_() const;
&#9;[[nodiscard]] bool @SG_ML_L082Bcontains#nodiscard_bool_contains_const_T_ref_const_(const T& x) const;
&#9;[[nodiscard]] int @SG_ML_L0527count#nodiscard_int_count_const_T_ref_const_(const T& x) const;
&#9;[[nodiscard]] @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator @SG_ML_L0335end#nodiscard_SGLUnorderedMultiSet_mc_Iterator_end_func_();
&#9;void @SG_ML_L0518erase#void_erase_const_T_ref_(const T& x);
&#9;void @SG_ML_L0531erase#void_erase_SGLUnorderedMultiSet_mc_Iterator_ref_(@SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator& x);
&#9;[[nodiscard]] @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator @SG_ML_L0448find#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_find_const_T_ref_const_(const T& x) const;
&#9;[[nodiscard]] @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator @SG_ML_L043Dfind#nodiscard_SGLUnorderedMultiSet_mc_Iterator_find_const_T_ref_(const T& x);
&#9;void @SG_ML_L0619insert#void_insert_const_T_ref_(const T& x);
&#9;[[nodiscard]] int @SG_ML_L0621length#nodiscard_int_length_func_const_() const;
&#9;void @SG_ML_L0712reserve#void_reserve_int_(int newMemoryLength);
@SG_ML_BLANKLINE
@SG_ML_HEADER_detaileddescription Detailed Description
@SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset provides a template based unordered multiset that can be used with any data type. Use @SG_ML_L0B0BSGLMultiSetsglmultiset instead if ordering matters. This is a template based class with no separate source file. This class is a SGEXTN container. Copy constructor, copy assignment, move constructor, move assignment, and destructor work as expected. A deep copy is performed whenever this class is copied, and the new instance will not be linked to the old instance in any way. It is assumed that the contents placed into this SGEXTN container can be copied and moved. This means that their copy constructor copy assignment, move constructor, move assignment, and destructor work as expected. If this is not the case or if you want the container to store references or constant references, store pointers instead.
@SG_ML_BLANKLINE
@SG_ML_HEADER_implementationdetails Implementation Details
@SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset maintains an open addressed linear probing hash table with a load factor of 0.33 Due to the extremely low load factor, @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset is much faster than most implementations of unordered map (especially the Standard Template Library one, which is not even open addressed) at the cost of higher memory usage. The hash table is stored in a C array memory buffer that triples in size when the load factor is reached. @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset does not store duplicate elements, instead it keeps track of the number of copies of each element using a int, so its internal structure resembles a @SG_ML_L0F0FSGLUnorderedMapsglunorderedmap<T, int, EqualityCheck, HashFunction>
@SG_ML_BLANKLINE
@SG_ML_HEADER_SGLUnorderedMultiSet_func_ @SG_ML_L141BSGLUnorderedMultiSet#SGLUnorderedMultiSet_func_();
Creates an empty @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMultiSet_mc_Iterator_begin_func_ [[nodiscard]] @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator @SG_ML_L0537begin#nodiscard_SGLUnorderedMultiSet_mc_Iterator_begin_func_();
Returns a iterator to the first element in the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_NOTE @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset iterators behave circularly. This is equivalent to running operator++ on @SG_ML_L1949SGLUnorderedMultiSet::endsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_Iterator_end_func_.
@SG_ML_NOTE @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator allows modifying the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset through it. If modification is not needed, use @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator instead. The @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator equivalent to this function is @SG_ML_L205BSGLUnorderedMultiSet::constBeginsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constBegin_func_const_.
@SG_ML_WARN If the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset is empty, this is the same as @SG_ML_L1949SGLUnorderedMultiSet::endsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_Iterator_end_func_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constBegin_func_const_ [[nodiscard]] @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator @SG_ML_L0A47constBegin#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constBegin_func_const_() const;
Returns a constant iterator to the first element in the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_NOTE @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset iterators behave circularly. This is equivalent to running operator++ on @SG_ML_L1E59SGLUnorderedMultiSet::constEndsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_.
@SG_ML_WARN If the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset is empty, this is the same as @SG_ML_L1E59SGLUnorderedMultiSet::constEndsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_ [[nodiscard]] @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator @SG_ML_L0845constEnd#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_() const;
Returns a null constant iterator associated to this @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_NOTE @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset iterators behave circularly. This is equivalent to running operator-- on @SG_ML_L205BSGLUnorderedMultiSet::constBeginsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constBegin_func_const_.
@SG_ML_WARN Attempting to access the element that this iterator points to is @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_bool_contains_const_T_ref_const_ [[nodiscard]] bool @SG_ML_L082Bcontains#nodiscard_bool_contains_const_T_ref_const_(const T& x) const;
Returns if the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset contains any copy of @SG_ML_B01x.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_count_const_T_ref_const_ [[nodiscard]] int @SG_ML_L0527count#nodiscard_int_count_const_T_ref_const_(const T& x) const;
Returns the number of copies of @SG_ML_B01x found in the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMultiSet_mc_Iterator_end_func_ [[nodiscard]] @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator @SG_ML_L0335end#nodiscard_SGLUnorderedMultiSet_mc_Iterator_end_func_();
Returns a null iterator associated to this @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_NOTE @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset iterators behave circularly. This is equivalent to running operator-- on @SG_ML_L1B4BSGLUnorderedMultiSet::beginsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_Iterator_begin_func_.
@SG_ML_NOTE @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator allows modifying the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset through it. If modification is not needed, use @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator instead. The @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator equivalent to this function is @SG_ML_L1E59SGLUnorderedMultiSet::constEndsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_.
@SG_ML_WARN Attempting to access the element that this iterator points to is @SG_ML_L131Fundefined behaviour../tutorials/undefinedbehaviour.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_erase_const_T_ref_ void @SG_ML_L0518erase#void_erase_const_T_ref_(const T& x);
Removes @SG_ML_B01x from the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_NOTE If there is more than 1 copies of @SG_ML_B01x, the last added copy is removed and other copies remain in the set.
@SG_ML_WARN If the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset does not contain any copy of @SG_ML_B01x, this will cause a crash. If you cannot guarantee that @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset contains @SG_ML_B01x, use @SG_ML_L1E3FSGLUnorderedMultiSet::containssglunorderedmultiset#nodiscard_bool_contains_const_T_ref_const_ to check before removal. This is a intentional design choice to avoid silent bugs.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_erase_SGLUnorderedMultiSet_mc_Iterator_ref_ void @SG_ML_L0531erase#void_erase_SGLUnorderedMultiSet_mc_Iterator_ref_(@SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator& x);
Removes the element associated with @SG_ML_B01x from the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
After the removal, @SG_ML_B01x which is passed as a reference, is decremented. This means that you do not have to do any special handling for removed elements when iterating over a @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_WARN Do not write any special logic to modify iterators while removing elements from a @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset in a loop, @SG_ML_L1B2CSGLUnorderedMultiSet::erasesglunorderedmultiset#void_erase_const_T_ref_@SG_ML_L1B45SGLUnorderedMultiSet::erasesglunorderedmultiset#void_erase_SGLUnorderedMultiSet_mc_Iterator_ref_ handles this for you automatically.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_find_const_T_ref_const_ [[nodiscard]] @SG_ML_L2323SGLUnorderedMultiSet::ConstIteratorsglunorderedmultiset__constiterator @SG_ML_L0448find#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_find_const_T_ref_const_(const T& x) const;
Returns the constant iterator pointing to element @SG_ML_B01x.
@SG_ML_NOTE @SG_ML_L1E59SGLUnorderedMultiSet::constEndsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_ConstIterator_constEnd_func_const_ is returned if @SG_ML_B01x is not in the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_SGLUnorderedMultiSet_mc_Iterator_find_const_T_ref_ [[nodiscard]] @SG_ML_L1E1ESGLUnorderedMultiSet::Iteratorsglunorderedmultiset__iterator @SG_ML_L043Dfind#nodiscard_SGLUnorderedMultiSet_mc_Iterator_find_const_T_ref_(const T& x);
Returns the iterator pointing to element @SG_ML_B01x.
@SG_ML_NOTE @SG_ML_L1949SGLUnorderedMultiSet::endsglunorderedmultiset#nodiscard_SGLUnorderedMultiSet_mc_Iterator_end_func_ is returned if @SG_ML_B01x is not in the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_insert_const_T_ref_ void @SG_ML_L0619insert#void_insert_const_T_ref_(const T& x);
Inserts @SG_ML_B01x into the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset.
@SG_ML_NOTE Inserting multiple elements is allowed. If there is already a copy of @SG_ML_B01x, a new copy is added.
@SG_ML_BLANKLINE
@SG_ML_HEADER_nodiscard_int_length_func_const_ [[nodiscard]] int @SG_ML_L0621length#nodiscard_int_length_func_const_() const;
Returns the length of the @SG_ML_L1414SGLUnorderedMultiSetsglunorderedmultiset, which is the number of elements that it contains.
@SG_ML_BLANKLINE
@SG_ML_HEADER_void_reserve_int_ void @SG_ML_L0712reserve#void_reserve_int_(int newMemoryLength);
Pre allocates sufficient memory to store (@SG_ML_B0FnewMemoryLength / 3) - 1 elements without exceeding the load factor.
@SG_ML_NOTE If sufficient memory is already allocated, this does nothing.
@SG_ML_BLANKLINE
