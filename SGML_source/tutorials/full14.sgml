@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME Full Tutorial Part 14
@SG_ML_TITLE Full Tutorial Part 14
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull13 for the previous part of the tutorial.
&#9;In the previous part, we built the progress bar on the display page
@SG_ML_BLANKLINE
@SG_ML_HEADER_ saving user data
&#9;Most applications will need to save user data across sessions. The dedicated SG_FileSystem module in SGEXTN makes this very convenient.
&#9;The user data in the case of Colours++ is the options that the user chose in the options page. These can be saved to a binary file using @SG_ML_L007013SGXFile../cppclass/sgxfile. Although SGEXTN technically supports saving to a text file, support is not good (at least in version 6.2.0) and binary files occupy less space and are faster to read and write compared to text files containing the same information. The only reason why you would consider storing user data in a text file is if you are building a tool for software engineers who would need to write configuration files.
&#9;The file system can be easily accessed through @SG_ML_L00D019SGXFileSystem../cppclass/sgxfilesystem, and @SG_ML_L007013SGXFile../cppclass/sgxfile is used to read from and write to binary files.
@SG_ML_BLANKLINE
&#9;We will implement a function that is called whenever "save current settings to preset" is clicked. For convenience, we will set the name of the preset to the current date. In a actual consumer facing app, it is likely better to let the user decide the name of files, but here we will leave out that to avoid being repetitive about UI.
@SG_ML_BLANKLINE
&#9;Firstly, we must get all the information about what the user has selected from the UI.
&#9;But wait... We have already done that when we built the submit button, inside the function SGCLPOptionsPage::submitOptions. If we are to implement the same logic again in another function, we would have 2 copies of the same code.
&#9;Having 2 copies of the same code is known as code duplication.
&#9;This is bad because whenever you need to make a change, you need to do it to both copies, slowing down development speed. Furthermore if you only make a change to 1 copy because you forgot the other one, it can lead to weird bugs that are difficult to catch during testing.
&#9;To avoid this, we can define a new function in SGCLPOptionsPage
@SG_ML_WARN static bool checkOptions();
&#9;and refactor the code currently inside SGCLPOptionsPage::submitOptions into 2 functions. The part that handles reading the UI will go to SGCLPOptionsPage::checkOptions while the part only run when submitting the options should stay in SGCLPOptionsPage::checkOptions.
&#9;This is known as modularising code and is good for preventing code duplication.
@SG_ML_WARN bool SGCLPOptionsPage::checkOptions(){&#10;    if((*SGCLPOptionsPage::polygonSideCountInput).getInvalid() == true && ((*SGCLPOptionsPage::patternPolygonButton).getSelected() == true || (*SGCLPOptionsPage::patternStarButton).getSelected() == true)){&#10;        SGWNotify::pullDownNotify("invalid number of vertices chosen");&#10;        return false;&#10;    }&#10;    SGCLPOptionsPage::chosenForegroundColour = (*SGCLPOptionsPage::foregroundColourPicker).getColour();&#10;    SGCLPOptionsPage::chosenBackgroundColour = SGCLPOptionsPage::chosenForegroundColour;&#10;    if((*SGCLPOptionsPage::backgroundUseCustomButton).getSelected() == true){SGCLPOptionsPage::chosenBackgroundColour = (*SGCLPOptionsPage::backgroundColourPicker).getColour();}&#10;    else{&#10;        SGXColourHSLA backgroundColourHSLA(SGCLPOptionsPage::chosenBackgroundColour);&#10;        if((*SGCLPOptionsPage::backgroundComplementaryHueButton).getSelected() == true){backgroundColourHSLA.invertHue();}&#10;        if((*SGCLPOptionsPage::backgroundComplementarySaturationButton).getSelected() == true){backgroundColourHSLA.invertSaturation();}&#10;        if((*SGCLPOptionsPage::backgroundComplementaryLightnessButton).getSelected() == true){backgroundColourHSLA.invertLightness();}&#10;        SGCLPOptionsPage::chosenBackgroundColour = backgroundColourHSLA.toRGBA();&#10;    }&#10;    if((*SGCLPOptionsPage::patternCircleButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Circle;}&#10;    else if((*SGCLPOptionsPage::patternPolygonButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Polygon;}&#10;    else if((*SGCLPOptionsPage::patternStarButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Star;}&#10;    else{SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Fractal;}&#10;    SGCLPOptionsPage::chosenVertexCount = (*SGCLPOptionsPage::polygonSideCountInput).getTextAsInt(nullptr, 3, SGLIntLimits::maximum());&#10;    return true;&#10;}&#10;&#10;void SGCLPOptionsPage::submitOptions(){&#10;    if(SGCLPOptionsPage::checkOptions() == false){return;}&#10;    SGWBackground::disable(SGCLPOptionsPage::instance);&#10;    SGCLPDisplayPage::activate();&#10;}
@SG_ML_BLANKLINE
&#9;Once that is done, we can proceed to actually implement the saving of presets. Let us define a function SGCLPOptionsPage::savePresets that will be called when the button is pressed and adjust the line of code that creates the button to use the @SG_ML_L021015callback function ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/callback. You should already know how to do this.
@SG_ML_WARN static void savePresets();
&#9;Inside this function, obviously first we check that the UI is in a valid state and the user did not choose something nonsensical for the number of vertices.
@SG_ML_WARN if(SGCLPOptionsPage::checkOptions() == false){return;}
&#9;Note how we are reusing the same code.
&#9;Next we can determine the file path of the preset file. In this case, we can let it be
@SG_ML_WARN [user data folder] / [current time].sg
&#9;In code, that is
@SG_ML_WARN SGXString fileName = SGXFileSystem::joinFilePaths(SGXFileSystem::userDataFilePath, SGXTimeStamp::now().getFileNameCorrectToSecondSeparated('_') + ".sg");
&#9;Note a few things here.
&#9;Firstly, we are using @SG_ML_L01C061SGXFileSystem::joinFilePaths../cppclass/sgxfilesystem#static_SGXString_joinFilePaths_const_SGXString_ref_const_SGXString_ref_ to join the parent folder path with the file name. This is helpful as we would not need to write the / by hand which can be annoying.
&#9;Also, we are putting the file inside @SG_ML_L01F03CSGXFileSystem::userDataFilePath../cppclass/sgxfilesystem#static_SGXString_userDataFilePath_. This is the folder dedicated to storing user data. User data in this case refers to the documents that the app generates, but excludes app settings or configuration files. App settings or configuration files should instead go under @SG_ML_L01D03ASGXFileSystem::configFilePath../cppclass/sgxfilesystem#static_SGXString_configFilePath_.
&#9;We use @SG_ML_L00C018SGXTimeStamp../cppclass/sgxtimestamp to get the current time as a string. Firstly @SG_ML_L011040SGXTimeStamp::now../cppclass/sgxtimestamp#nodiscard_static_SGXTimeStamp_now_func_ gives the current time as a @SG_ML_L00C018SGXTimeStamp../cppclass/sgxtimestamp object. After that, @SG_ML_L03105FSGXTimeStamp::getFileNameCorrectToSecondSeparated../cppclass/sgxtimestamp#nodiscard_SGXString_getFileNameCorrectToSecondSeparated_SGXChar_const_ gives the string representation in a format compatible with the file system. This function also allows you to choose the separator used, which can be ' ', '-', or '_' depending on use case.
&#9;@SG_ML_L00C018SGXTimeStamp../cppclass/sgxtimestamp converts everything to Singapore time zone, so you can either always use Singapore time zone in your app (recommended), or convert from the user's device time zone to Singapore time zone manually. In some places like Canadian Toronto, they like to randomly change the time zone for no reason at all. If you want to take that into account, you can use QDateTime to perform conversions properly.
&#9;Lastly note that the file extension is .sg, this is done for all SGEXTN application files that are not meant to be exported. In other words, the user will never actually see the file or need to manually transfer it somewhere. If the file needs to be exported, it is better to use a application specific extension.
@SG_ML_BLANKLINE
&#9;Then we check if the file already exists. If it does, it means the user has been saving presets more than once this second. That likely indicates they are spamming the save button, so we ignore it.
@SG_ML_WARN if(SGXFileSystem::fileExists(fileName)){return;}
&#9;Here @SG_ML_L019045SGXFileSystem::fileExists../cppclass/sgxfilesystem#static_bool_fileExists_const_SGXString_ref_ is used to check if a file exists. There is also @SG_ML_L01B047SGXFileSystem::folderExists../cppclass/sgxfilesystem#static_bool_folderExists_const_SGXString_ref_ to check if a folder exists. You may also find @SG_ML_L01B05BSGXFileSystem::getFilesList../cppclass/sgxfilesystem#static_SGLArray_lt_SGXString_gt_getFilesList_const_SGXString_ref_ helpful, which gives a list of files in a folder of your choice.
@SG_ML_BLANKLINE
&#9;After these checks, we can be sure that the preset needs to be saved and also whatever the user input is valid. We can then use @SG_ML_L019044SGXFileSystem::createFile../cppclass/sgxfilesystem#static_int_createFile_const_SGXString_ref_ to make a new empty binary file and then use @SG_ML_L007013SGXFile../cppclass/sgxfile to write stuff into it.
&#9;@SG_ML_L007013SGXFile../cppclass/sgxfile has a lot of commands for reading and writing a wide variety of data types. This includes both C++ stuff such as int and float, and also SGEXTN structs such as @SG_ML_L00D019SGXColourRGBA../cppclass/sgxcolourrgba and @SG_ML_L00D019SGXIdentifier../cppclass/sgxidentifier.
@SG_ML_WARN SGXFileSystem::createFile(fileName);&#10;SGXFile file(fileName);&#10;file.writeColourRGBA(SGCLPOptionsPage::chosenForegroundColour);&#10;file.writeColourRGBA(SGCLPOptionsPage::chosenBackgroundColour);&#10;if(SGCLPOptionsPage::chosenPattern == SGCLPOptionsPage::Circle){file.writeInt(1);}&#10;else if(SGCLPOptionsPage::chosenPattern == SGCLPOptionsPage::Polygon){file.writeInt(2);}&#10;else if(SGCLPOptionsPage::chosenPattern == SGCLPOptionsPage::Star){file.writeInt(3);}&#10;else if(SGCLPOptionsPage::chosenPattern == SGCLPOptionsPage::Fractal){file.writeInt(4);}&#10;else{file.writeInt(0);}&#10;file.writeInt(SGCLPOptionsPage::chosenVertexCount);
&#9;Note that the enum is not written directly although technically enums can be casted to int. This is because if in future you want to add a new enum, the number that each enum currently corresponds to may shift. That would corrupt existing preset files. By manually converting them, you ensure that the code is future-proof and behaves consistently across compilers and devices.
&#9;For the same reason, 0 is written as the chosen pattern if the enum chosen is not any of the 4. Currently this is impossible, but future updates may add more enums and you may forget to update your code somewhere to handle these extra enums. In that case, having it write a invalid value makes the failure consistent and helps with debugging.
@SG_ML_BLANKLINE
&#9;We can proceed to test the feature by clicking the button and checking if any file is created in the Documents/ColoursPlusPlus/yourdata folder. Assuming that you have done everything correctly, you should be able to find files with the extension .sg there, proving that the presets have actually been saved successfully.
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull15 for the next part of the tutorial.
&#9;
