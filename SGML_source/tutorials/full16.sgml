@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME Full Tutorial Part 16
@SG_ML_TITLE Full Tutorial Part 16
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull15 for the previous part of the tutorial.
&#9;In the previous part, we built the functionality of using previously saved presets.
@SG_ML_BLANKLINE
@SG_ML_HEADER_ shaders (part 1)
&#9;In this part of the tutorial, we will be writing shaders and using the SG - RI system to actually make the display page display stuff.
&#9;SG - RI lets you use shaders really easily and also integrates into @SG_ML_L018015SGWidget ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/sgwidget. Before we continue, first read through this @SG_ML_L008008tutorialrenderer here.
@SG_ML_BLANKLINE
&#9;Now that you have read through the tutorial, we can start programming. Firstly, we have to decide how each pattern will be displayed.
&#9;For the circle pattern, we will use a texture for the circle itself and do processing on the fragment shader to see if a pixel is inside the circle. This demonstrates the use of textures and also writing fragment shader code.
&#9;For the polygon and star patterns, we will have the actual geometry of the shapes encoded via vertices to demonstrate the generation and usage of the vertex buffer object and the fragment buffer object.
&#9;For the fractal pattern, we will render a Mandelbrot set. Obviously this must be done on the fragment shader.
@SG_ML_BLANKLINE
&#9;We write code to display the circle first.
&#9;First we write the vertex shader.
@SG_ML_WARN #version 310 es&#10;precision highp float;&#10;precision highp int;&#10;layout(std140, binding = 0) uniform SG_RI_builtin_{&#10;    float x;&#10;    float y;&#10;    float width;&#10;    float height;&#10;    float windowWidth;&#10;    float windowHeight;&#10;    int offscreen;&#10;} SG_RI_builtin;&#10;vec4 SG_RI_transform(vec4 prelimPosition){&#10;    prelimPosition = vec4(2.0f * (prelimPosition.x * SG_RI_builtin.width / SG_RI_builtin.windowWidth + SG_RI_builtin.x / SG_RI_builtin.windowWidth) - 1.0f, -2.0f * (prelimPosition.y * SG_RI_builtin.height / SG_RI_builtin.windowHeight + SG_RI_builtin.y / SG_RI_builtin.windowHeight) + 1.0f, prelimPosition.z, prelimPosition.w);&#10;    if(SG_RI_builtin.offscreen != 0){prelimPosition = vec4(prelimPosition.x, -1.0f * prelimPosition.y, prelimPosition.z, prelimPosition.w);}&#10;    return prelimPosition;&#10;}&#10;&#10;layout(location = 0) in vec2 vertex;&#10;layout(location = 0) out vec2 vertexCoords;&#10;&#10;void main(){&#10;    gl_Position = vec4(vertex.x, vertex.y, 0.0f, 1.0f);&#10;    vertexCoords = vec2(2.0f * vertex.x - 1.0f, 2.0f * vertex.y - 1.0f);&#10;    if(SG_RI_builtin.width &gt; SG_RI_builtin.height){vertexCoords = vec2(vertexCoords.x * SG_RI_builtin.width / SG_RI_builtin.height, vertexCoords.y);}&#10;    else{vertexCoords = vec2(vertexCoords.x, vertexCoords.y * SG_RI_builtin.height / SG_RI_builtin.width);}&#10;&#10;    gl_Position = SG_RI_transform(gl_Position);&#10;}
&#9;The vertex shader takes input from the element buffer object a vec2 called vertex. It then applies transforms to change it to vertexCoords, which is sent to the fragment shader to determine how to colour each pixel.
&#9;vertexCoords is in a coordinate system centered at the center of the screen, with the minimum of the screen width and the screen height being 2 units long. This makes it easier to draw the circle, since it will just be centered at the origin with radius 0.75.
&#9;The vertex shader also directly passes the vertex variable into gl_Position which decides where the vertex should be displayed on screen. Combined with the data that we will put in the vertex buffer object later, this will create a full screen quad.
@SG_ML_BLANKLINE
&#9;The fragment shader is also really simple.
@SG_ML_WARN #version 310 es&#10;precision highp float;&#10;precision highp int;&#10;layout(std140, binding = 1) uniform data_{&#10;    vec4 backgroundColour;&#10;} data;&#10;layout(binding = 0) uniform sampler2D textureSampler;&#10;layout(location = 0) in vec2 vertexCoords;&#10;layout(location = 0) out vec4 outColour;&#10;&#10;void main(){&#10;    if(vertexCoords.x * vertexCoords.x + vertexCoords.y * vertexCoords.y &gt; 0.75f * 0.75f){outColour = data.backgroundColour;}&#10;    else{outColour = texture(textureSampler, vertexCoords);}&#10;}
&#9;It simply checks if the pixel coordinate is inside the circle. If inside the circle, the fragment shader colours it using the image. Otherwise it uses the background colour.
&#9;To ensure that @SG_ML_L018015BuildLah ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/buildlah recognises these shaders, we have to put them inside the shaders/ folder, as shaders/circle.vert and shaders/circle.frag respectively.
@SG_ML_BLANKLINE
&#9;With the GLSL side done, we proceed to work on the C++ side.
&#9;First we make 2 files, include/SGCLPCircleDisplay.h and src/SGCLPCircleDisplay.cpp
&#9;We create a new class, SGCLPCircleDisplay, for the SG - RI powered renderer that will display the circle. Inside the class, apart from implementing all the pure virtual functions from @SG_ML_L00F01BSGRBaseRenderer../cppclass/sgrbaserenderer, we also need to store the background colour, the vertex buffer object, the element buffer object, and the image texture.
@SG_ML_WARN class SGCLPCircleDisplay : public SGRBaseRenderer {&#10;public:&#10;    SGCLPCircleDisplay(SGXColourRGBA bg);&#10;    SGXColourRGBA backgroundColour;&#10;    SGRRenderingProgramme* createRenderingProgramme() override;&#10;    void initialise() override;&#10;    void cleanResourcesOnDestruction() override;&#10;    void uploadShaderData() override;&#10;    void requestRenderCommands(SGRCommandRequest* commandRequest) override;&#10;    SGRVertexBufferObject* vbo;&#10;    SGRElementBufferObject* ebo;&#10;    SGRImage* textureImage;&#10;};
&#9;Note that @SG_ML_L00F01BSGRBaseRenderer../cppclass/sgrbaserenderer does NOT own the vertex buffer object and the fragment buffer object. These must be managed manually.
@SG_ML_BLANKLINE
&#9;Inside src/SGCLPCircleDisplay.cpp we can implement all the functions on SGCLPCircleDisplay.
&#9;Firstly, we write the constructor which sets the background colour.
@SG_ML_WARN SGCLPCircleDisplay::SGCLPCircleDisplay(SGXColourRGBA bg){&#10;    (*this).backgroundColour = bg;&#10;    (*this).vbo = nullptr;&#10;    (*this).ebo = nullptr;&#10;    (*this).textureImage = nullptr;&#10;}
&#9;The destructor also has nothing interesting. It just frees all the memory.
@SG_ML_WARN void SGCLPCircleDisplay::cleanResourcesOnDestruction(){&#10;    delete vbo;&#10;    delete ebo;&#10;    delete textureImage;&#10;}
@SG_ML_BLANKLINE
&#9;The implementation of @SG_ML_L029063SGRBaseRenderer::createRenderingProgramme../cppclass/sgrbaserenderer#virtual_SGRRenderingProgramme_ptr_createRenderingProgramme_func_assign_ is much more interesting.
@SG_ML_WARN SGRRenderingProgramme* SGCLPCircleDisplay::createRenderingProgramme(){&#10;    SGRRenderingProgramme* rp = new SGRRenderingProgramme(this);&#10;    (*rp).setShaderQSBFiles(":/ColoursPlusPlus/circle.vert.qsb", ":/ColoursPlusPlus/circle.frag.qsb");&#10;    (*rp).addUniformBufferObject(16, 1);&#10;    (*rp).addTexture(0);&#10;    (*rp).finaliseShaderResource();&#10;    (*rp).addVertexBufferObject(2 * 4);&#10;    (*rp).addVertexProperty(0, 0, 0, SGRGraphicsLanguageType::Float, 2);&#10;    (*rp).finaliseVertices();&#10;    (*rp).finaliseRenderingProgramme();&#10;    return rp;&#10;}
&#9;Here we provide information about how the shader will behave. Firstly, we use @SG_ML_L028061SGRRenderingProgramme::setShaderQSBFiles../cppclass/sgrrenderingprogramme#void_setShaderQSBFiles_const_SGXString_ref_const_SGXString_ref_ to provide the GLSL code.
&#9;Then we add a uniform buffer object of size 16 at binding point 1. 16 bytes is just enough to contain 1 vec4 for the background colour, and the binding point of 1 matches our declaration in GLSL.
@SG_ML_WARN layout(std140, binding = 1) uniform data_{ ... } data;
&#9;We also add a texture at binding point 0. Again note how the binding point of 0 matches the GLSL declaration of the texture sampler.
@SG_ML_WARN layout(binding = 0) uniform sampler2D textureSampler;
&#9;Once the uniform buffer object and texture are set up, we create a slot for a vertex buffer object using @SG_ML_L02C047SGRRenderingProgramme::addVertexBufferObject../cppclass/sgrrenderingprogramme#void_addVertexBufferObject_int_const_. The argument of 2 * 4 indicates that 8 bytes (2 floats x 4 bytes per float) are used per vertex. This is just enough to contain a vec2, which is our coordinates from the vertex buffer object.
&#9;@SG_ML_L02806FSGRRenderingProgramme::addVertexProperty../cppclass/sgrrenderingprogramme#void_addVertexProperty_int_int_int_SGRGraphicsLanguageType_mc_Type_int_const_ is then used to tell the GPU that the 8 bytes of data is a vec2.
&#9;After the @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme (or rendering pipeline) is set up, we return a pointer to it which SG - RI internally uses for further processing.
@SG_ML_BLANKLINE
&#9;We then can implement initialisation of the display.
@SG_ML_WARN void SGCLPCircleDisplay::initialise(){&#10;    vbo = new SGRVertexBufferObject(this, 4 * 2 * 4);&#10;    SGLArray&lt;float&gt; vt(0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);&#10;    (*renderingProgramme()).updateDataBuffer(vbo, 0, 4 * 2 * 4, vt.pointerToData(0));&#10;    ebo = new SGRElementBufferObject(this, 2 * 3 * 4);&#10;    SGLArray&lt;int&gt; et(0, 1, 2, 1, 2, 3);&#10;    (*renderingProgramme()).updateDataBuffer(ebo, 0, 2 * 3 * 4, et.pointerToData(0));&#10;    textureImage = new SGRImage(":/ColoursPlusPlus/conjugates.png");&#10;    (*renderingProgramme()).updateTexture(0, textureImage);&#10;    SGLArray&lt;float&gt; ut(backgroundColour.getRedAsFloat(), backgroundColour.getGreenAsFloat(), backgroundColour.getBlueAsFloat(), backgroundColour.getTransparencyAsFloat());&#10;    (*renderingProgramme()).updateShaderUniforms(1, 0, 16, ut.pointerToData(0));&#10;}
&#9;Here we create the vertex buffer object, element buffer object, and texture. We then upload these to the GPU. Since these do not change throughout the rendering process, they are created and uploaded once inside @SG_ML_L01B040SGRBaseRenderer::initialise../cppclass/sgrbaserenderer#virtual_void_initialise_func_assign_ and not touched inside @SG_ML_L021046SGRBaseRenderer::uploadShaderData../cppclass/sgrbaserenderer#virtual_void_uploadShaderData_func_assign_.
&#9;Note that the values used for the vertex buffer object and element buffer object here will give a fullscreen quad in SG - RI.
&#9;The image is a random image I found on my computer, anything will work as long as it is inside the assets/ folder so @SG_ML_L018015BuildLah ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/buildlah will include it.
&#9;Since the background colour does not change, we can also write the uniform buffer object here with the background colour data. However note that in most shader setups, uniforms constantly update and will need to be written to every frame in @SG_ML_L021046SGRBaseRenderer::uploadShaderData../cppclass/sgrbaserenderer#virtual_void_uploadShaderData_func_assign_.
@SG_ML_BLANKLINE
&#9;Lastly we tell the GPU what to do every frame.
@SG_ML_WARN void SGCLPCircleDisplay::uploadShaderData(){&#10;&#10;}&#10;&#10;void SGCLPCircleDisplay::requestRenderCommands(SGRCommandRequest *commandRequest){&#10;    (*commandRequest).addVertexBufferObject(vbo, 0);&#10;    (*commandRequest).chooseElementBufferObject(ebo);&#10;    (*commandRequest).finaliseForDraw();&#10;    (*commandRequest).drawTriangles(2, 0);&#10;}
&#9;Since there is no per frame changing data, @SG_ML_L021046SGRBaseRenderer::uploadShaderData../cppclass/sgrbaserenderer#virtual_void_uploadShaderData_func_assign_ does literally nothing.
&#9;@SG_ML_L02605CSGRBaseRenderer::requestRenderCommands../cppclass/sgrbaserenderer#virtual_void_requestRenderCommands_SGRCommandRequest_ptr_assign_ binds the vertex buffer object and element buffer object before asking the GPU to draw 2 triangles to give a fullscreen quad. Note that the vertex buffer object and element buffer object must be selected every frame in SG - RI. This is different from the behaviour in OpenGL.
@SG_ML_BLANKLINE
&#9;To actually display the renderer on screen, we need to create a @SG_ML_L01101DSGRRendererWidget../cppclass/sgrrendererwidget that uses it. We can add this line of code
@SG_ML_WARN if(SGCLPOptionsPage::chosenPattern == SGCLPOptionsPage::Circle){new SGRRendererWidget(bg, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, -1.0f, new SGCLPCircleDisplay(SGCLPOptionsPage::chosenBackgroundColour), nullptr);}
&#9;to the end of SGCLPDisplayPage::initialise so that the application creates the renderer when showing the display page.
@SG_ML_BLANKLINE
&#9;With the code done, we can run our app again. As expected, display the circle works perfectly. We can then run a clang-tidy check and commit everything onto GitHub.
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull17 for the next part of the tutorial.
&#9;
