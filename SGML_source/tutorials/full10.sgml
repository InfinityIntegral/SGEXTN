@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME Full Tutorial Part 10
@SG_ML_TITLE Full Tutorial Part 10
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull09 for the previous part of the tutorial.
&#9;In the previous part, we wrote the behaviour of the input field in the options page.
@SG_ML_BLANKLINE
@SG_ML_HEADER_ writing options page behaviour (final part)
&#9;Noe the options page is done (we will write the presets system later, ignore it for now), we need to extract data from the UI for processing by the application.
&#9;We can use @SG_ML_L01603CSGWButton::getSelected../cppclass/sgwbutton#nodiscard_bool_getSelected_func_const_, @SG_ML_L01403ASGWInput::getInvalid../cppclass/sgwinput#nodiscard_bool_getInvalid_func_const_, @SG_ML_L02004FSGWColourPickerWidget::getColour../cppclass/sgwcolourpickerwidget#nodiscard_SGXColourRGBA_getColour_func_const_, @SG_ML_L016047SGWInput::getTextAsInt../cppclass/sgwinput#nodiscard_int_getTextAsInt_bool_ptr_int_int_const_, @SG_ML_L01804FSGWInput::getTextAsFloat../cppclass/sgwinput#nodiscard_float_getTextAsFloat_bool_ptr_float_float_const_, and @SG_ML_L019044SGWInput::getTextAsString../cppclass/sgwinput#nodiscard_SGXString_getTextAsString_func_const_ to do this.
&#9;Before we do that, we should first make a function SGCLPOptionsPage::submitOptions and call it whenever the submit button is pressed. By now you should already know how to do that. We will focus on implementing the function.
@SG_ML_BLANKLINE
&#9;First we check if the input field for the number of vertices is valid. If the value is relevant but it is not valid, then we prevent the user from actually submitting the options.
&#9;To warn the user about invalid input, we can use @SG_ML_L019045SGWNotify::pullDownNotify../cppclass/sgwnotify#static_void_pullDownNotify_const_SGXString_ref_. To display informational messages, use @SG_ML_L01103DSGWNotify::notify../cppclass/sgwnotify#static_void_notify_const_SGXString_ref_.
@SG_ML_WARN if((*SGCLPOptionsPage::polygonSideCountInput).getInvalid() == true && ((*SGCLPOptionsPage::patternPolygonButton).getSelected() == true || (*SGCLPOptionsPage::patternStarButton).getSelected() == true)){&#10;    SGWNotify::pullDownNotify("invalid number of vertices chosen");&#10;    return;&#10;}
&#9;If this does not trigger, it would mean that everything is ok. In that case, we can save the chosen options for the next part of the application to process.
@SG_ML_BLANKLINE
&#9;When we turn off this UI page, the UI elements on screen will be destroyed and the data will be gone, so we have to save it in static variables first. We can declare the static variables first.
@SG_ML_WARN static SGXColourRGBA chosenBackgroundColour;&#10;static SGXColourRGBA chosenForegroundColour;&#10;enum Pattern{&#10;    Circle,&#10;    Polygon,&#10;    Star,&#10;    Fractal&#10;};&#10;static Pattern chosenPattern;&#10;static int chosenVertexCount;
&#9;Here we use a enum for the pattern type as it gives better readability. In SGEXTN, unlike in Qt, there is no registration or MetaObject processing required for enums.
&#9;As usual, we have to declare these in the source file.
@SG_ML_WARN SGXColourRGBA SGCLPOptionsPage::chosenForegroundColour = SGXColourRGBA(255, 0, 200);&#10;SGXColourRGBA SGCLPOptionsPage::chosenBackgroundColour = SGXColourRGBA(255, 255, 255);&#10;SGCLPOptionsPage::Pattern SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Circle;&#10;int SGCLPOptionsPage::chosenVertexCount = 3;
@SG_ML_BLANKLINE
&#9;Then we save everything into static variables.
@SG_ML_WARN SGCLPOptionsPage::chosenForegroundColour = (*SGCLPOptionsPage::foregroundColourPicker).getColour();&#10;SGCLPOptionsPage::chosenBackgroundColour = SGCLPOptionsPage::chosenForegroundColour;&#10;if((*SGCLPOptionsPage::backgroundUseCustomButton).getSelected() == true){SGCLPOptionsPage::chosenBackgroundColour = (*SGCLPOptionsPage::backgroundColourPicker).getColour();}&#10;else{&#10;    SGXColourHSLA backgroundColourHSLA(SGCLPOptionsPage::chosenBackgroundColour);&#10;    if((*SGCLPOptionsPage::backgroundComplementaryHueButton).getSelected() == true){backgroundColourHSLA.invertHue();}&#10;    if((*SGCLPOptionsPage::backgroundComplementarySaturationButton).getSelected() == true){backgroundColourHSLA.invertSaturation();}&#10;    if((*SGCLPOptionsPage::backgroundComplementaryLightnessButton).getSelected() == true){backgroundColourHSLA.invertLightness();}&#10;    SGCLPOptionsPage::chosenBackgroundColour = backgroundColourHSLA.toRGBA();&#10;}&#10;if((*SGCLPOptionsPage::patternCircleButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Circle;}&#10;else if((*SGCLPOptionsPage::patternPolygonButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Polygon;}&#10;else if((*SGCLPOptionsPage::patternStarButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Star;}&#10;else{SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Fractal;}&#10;SGCLPOptionsPage::chosenVertexCount = (*SGCLPOptionsPage::polygonSideCountInput).getTextAsInt(nullptr, 3, SGLIntLimits::maximum());
&#9;Note that we use @SG_ML_L01603CSGWButton::getSelected../cppclass/sgwbutton#nodiscard_bool_getSelected_func_const_ to check if a selectable button is currently selected.
&#9;@SG_ML_L00D019SGXColourRGBA../cppclass/sgxcolourrgba and @SG_ML_L00D019SGXColourHSLA../cppclass/sgxcolourhsla have a wide variety of utility functions for colour processing. Most SGEXTN APIs take @SG_ML_L00D019SGXColourRGBA../cppclass/sgxcolourrgba as input and output, so for representing colours, @SG_ML_L00D019SGXColourRGBA../cppclass/sgxcolourrgba should always be used. If you need HSL stuff, you can convert a @SG_ML_L00D019SGXColourRGBA../cppclass/sgxcolourrgba to a @SG_ML_L00D019SGXColourHSLA../cppclass/sgxcolourhsla using the constructor of @SG_ML_L00D019SGXColourHSLA../cppclass/sgxcolourhsla that takes a @SG_ML_L00D019SGXColourRGBA../cppclass/sgxcolourrgba, process it, then convert it back using @SG_ML_L015044SGXColourHSLA::toRGBA../cppclass/sgxcolourhsla#nodiscard_SGXColourRGBA_toRGBA_func_const_.
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull11 for the next part of the tutorial.
&#9;
