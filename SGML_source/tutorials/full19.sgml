@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME Full Tutorial Part 19
@SG_ML_TITLE Full Tutorial Part 19
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull18 for the previous part of the tutorial.
&#9;In the previous part, we built the star display.
@SG_ML_BLANKLINE
@SG_ML_HEADER_ shaders (part 4)
&#9;Now we will build the last component of the application, the fractal display.
&#9;We will use the fragment shader to render a Mandelbrot set on a full screen quad. This is to demonstrate the capability of SG - RI custom renderers.
&#9;The code on the C++ side will be really similar to the circle display except that there is no image texture this time. As practise, you can implement that yourself. We will be focusing on the shaders instead.
@SG_ML_BLANKLINE
@SG_ML_WARN void main(){&#10;    gl_Position = vec4(vertex.x, vertex.y, 0.0f, 1.0f);&#10;    vertexCoords = vec2(2.0f * vertex.x - 1.0f, 2.0f * vertex.y - 1.0f);&#10;    if(SG_RI_builtin.width &gt; SG_RI_builtin.height){vertexCoords = vec2(vertexCoords.x * SG_RI_builtin.width / SG_RI_builtin.height, vertexCoords.y);}&#10;    else{vertexCoords = vec2(vertexCoords.x, vertexCoords.y * SG_RI_builtin.height / SG_RI_builtin.width);}&#10;    vertexCoords = vec2(1.5f * vertexCoords.x - 0.5f, 1.5f * vertexCoords.y);&#10;&#10;    gl_Position = SG_RI_transform(gl_Position);&#10;}
&#9;The vertex shader is almost the same as the one used for the circle display, with only 1 difference. Instead of [-1.0, 1.0] on both directions being guranteed to be inside the display, we use [-2.0, 1.0] on the x axis and [-1.5, 1.5] on the y axis to fit the dimensions of the Mandelbrot set.
@SG_ML_BLANKLINE
&#9;And here is the fragment shader where the computation is done.
@SG_ML_WARN #version 310 es&#10;precision highp float;&#10;precision highp int;&#10;layout(std140, binding = 1) uniform data_{&#10;    vec4 foregroundColour;&#10;    vec4 backgroundColour;&#10;} data;&#10;&#10;layout(location = 0) in vec2 vertexCoords;&#10;layout(location = 0) out vec4 outColour;&#10;&#10;void main(){&#10;    vec2 currentValue = vec2(0.0f, 0.0f);&#10;    for(int i=0; i&lt;500; i++){&#10;        currentValue = vec2(currentValue.x * currentValue.x - currentValue.y * currentValue.y, 2.0f * currentValue.x * currentValue.y) + vertexCoords;&#10;        if(currentValue.x * currentValue.x + currentValue.y * currentValue.y &gt; 4.0f){break;}&#10;    }&#10;    if(currentValue.x * currentValue.x + currentValue.y * currentValue.y &gt; 4.0f){outColour = data.backgroundColour;}&#10;    else{outColour = data.foregroundColour;}&#10;}
&#9;Note that GLSL also has conditionals and loops, just that using them slows down your shader slightly.
&#9;Testing your application should show that the shader works as expected, so we can proceed with a final clang-tidy check and Git commit.
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull20 for the next part of the tutorial.
&#9;
