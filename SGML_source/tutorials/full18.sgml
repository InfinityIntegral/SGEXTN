@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME Full Tutorial Part 18
@SG_ML_TITLE Full Tutorial Part 18
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull17 for the previous part of the tutorial.
&#9;In the previous part, we built the polygon display.
@SG_ML_BLANKLINE
@SG_ML_HEADER_ shaders (part 3)
&#9;Next we will be building the star display. Similar to how we built the polygon display, we will define the shape of the star using actual vertices stored in the vertex buffer object. The coordinate system used by the vertices will be the same as those of the polygon, so we can reuse the same vertex and fragment shaders. We will use a @SG_ML_L00E01ASGWBlankWidget../cppclass/sgwblankwidget for the background.
&#9;At this point, you have already implemented 2 shaders, 1 for the circle and 1 for the polygon. You can try to entirely implement this by yourself. The location of the vertices can be easily determined using trigonometry and geometry from lower secondary mathematics.
@SG_ML_BLANKLINE
&#9;In case you cannot figure out how to generate the vertex buffer object and element buffer object, the code for SGCLPStarDisplay::initialise is here.
@SG_ML_WARN void SGCLPStarDisplay::initialise(){&#10;    SGLArray&lt;float&gt; vt(2 * (1 + 2 * vertexCount));&#10;    vt.at(0) = 0.0f;&#10;    vt.at(1) = 0.0f;&#10;    float outerRadius = 0.9f;&#10;    float innerRadius = outerRadius * SGLFloatMath::sine(0.1f * SGLFloatConstants::pi()) / SGLFloatMath::sine(0.7f * SGLFloatConstants::pi());&#10;    for(int i=0; i&lt;vertexCount; i++){&#10;        float angle = -0.5f * SGLFloatConstants::pi() + 2.0f * SGLFloatConstants::pi() /static_cast&lt;float&gt;(vertexCount) * (static_cast&lt;float&gt;(i) + 0.5f);&#10;        vt.at(2 + 2 * i) = innerRadius * SGLFloatMath::cosine(angle);&#10;        vt.at(3 + 2 * i) = innerRadius * SGLFloatMath::sine(angle);&#10;    }&#10;    for(int i=0; i&lt;vertexCount; i++){&#10;        float angle = -0.5f * SGLFloatConstants::pi() + 2.0f * SGLFloatConstants::pi() /static_cast&lt;float&gt;(vertexCount) * static_cast&lt;float&gt;(i);&#10;        vt.at(2 + 2 * vertexCount + 2 * i) = outerRadius * SGLFloatMath::cosine(angle);&#10;        vt.at(3 + 2 * vertexCount + 2 * i) = outerRadius * SGLFloatMath::sine(angle);&#10;    }&#10;    vbo = new SGRVertexBufferObject(this, 4 * 2 * (1 + 2 * vertexCount));&#10;    (*renderingProgramme()).updateDataBuffer(vbo, 0, 4 * 2 * (1 + 2 * vertexCount), vt.pointerToData(0));&#10;    SGLArray&lt;int&gt; et(3 * 2 * vertexCount);&#10;    for(int i=0; i&lt;vertexCount; i++){&#10;        et.at(3 * i) = 0;&#10;        et.at(3 * i + 1) = i + 1;&#10;        et.at(3 * i + 2) = i + 2;&#10;    }&#10;    et.at(3 * vertexCount - 1) = 1;&#10;    for(int i=0; i&lt;vertexCount; i++){&#10;        et.at(3 * vertexCount + 3 * i) = i + 1;&#10;        et.at(3 * vertexCount + 3 * i + 1) = i + 2;&#10;        et.at(3 * vertexCount + 3 * i + 2) = vertexCount + i + 2;&#10;    }&#10;    et.at(6 * vertexCount - 2) = 1;&#10;    et.at(6 * vertexCount - 1) = vertexCount + 1;&#10;    ebo = new SGRElementBufferObject(this, 4 * 3 * 2 * vertexCount);&#10;    (*renderingProgramme()).updateDataBuffer(ebo, 0, 4 * 3 * 2 * vertexCount, et.pointerToData(0));&#10;    SGLArray&lt;float&gt; ut(foregroundColour.getRedAsFloat(), foregroundColour.getGreenAsFloat(), foregroundColour.getBlueAsFloat(), foregroundColour.getTransparencyAsFloat());&#10;    (*renderingProgramme()).updateShaderUniforms(1, 0, 16, ut.pointerToData(0));&#10;}
&#9;When we were writing SGCLPPolygonDisplay, we focused on trigulations. Now we will focus on the actual implementation.
&#9;First note that instead of using ‹cmath› to get sine and cosine and ‹numbers› to get the value of pi, we used @SG_ML_L00C018SGLFloatMath../cppclass/sglfloatmath and @SG_ML_L01101DSGLFloatConstants../cppclass/sglfloatconstants. These are SGEXTN wrappers for the same Standard Template Library functions. Using these means that you do not need to include ‹cmath› and ‹numbers› to use their functionality, allowing much faster clang-tidy passes.
&#9;Apart from @SG_ML_L01101DSGLFloatConstants../cppclass/sglfloatconstants and @SG_ML_L00C018SGLFloatMath../cppclass/sglfloatmath, there is also @SG_ML_L00E01ASGLFloatLimits../cppclass/sglfloatlimits, @SG_ML_L00A016SGLIntMath../cppclass/sglintmath, @SG_ML_L00C018SGLIntLimits../cppclass/sglintlimits, @SG_ML_L00F01BSGLLongLongMath../cppclass/sgllonglongmath, and @SG_ML_L01101DSGLLongLongLimits../cppclass/sgllonglonglimits. These also wrap ‹cmath›, ‹numbers›, and ‹numeric_limits›, speeding up clang-tidy checks.
@SG_ML_BLANKLINE
&#9;Once you have done testing and debugging, you can run a clang-tidy check and commit to GitHub.
@SG_ML_BLANKLINE
&#9;See @SG_ML_L004006herefull19 for the next part of the tutorial.
&#9;
