@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.
@SG_ML_PAGENAME SGEXTN Renderer Interface Tutorial
@SG_ML_TITLE SGEXTN Renderer Interface Tutorial
@SG_ML_BLANKLINE
&#9;SG - RI allows you to use custom shaders without worrying about all the nonsense that OpenGL, Vulkan, or even QRhi forces you to do. If you do not know what these are, that is excellent, since this page is designed for beginners in GPU programming.
&#9;This tutorial will guide you through programming the custom renderers that you see when you open a SGEXTN colour picker.
@SG_ML_BLANKLINE
&#9;So what is the GPU again?
@SG_ML_BLANKLINE
&#9;The GPU is a different chip from your CPU (which runs C++ code) that draws stuff on the screen. It can do other stuff also, but for the purposes of this tutorial, we will think of it just as a chip that draws stuff on the screen.
&#9;The GPU is completely different from the CPU, so C++ does not work there. Instead, we use GLSL to programme it.
&#9;GLSL really looks similar to C++, so if you do not know how to use it, you can just write C++ and get DeepSeek or ChatGPT to translate it for you, and you will still be able to understand it. We will assume that you either know GLSL or you are able to translate C++ to GLSL using AI tools.
@SG_ML_BLANKLINE
&#9;The GPU draws triangles, a lot of triangles, really quickly. When drawing a triangle, it first look for the data of the triangles inside a array called a vertex buffer object (VBO). After that, it applies transformations to the vertices of the triangle to move that triangle to where it should be on the screen. The vertex shader is a GLSL programme that tells the GPU how to apply transformations to the triangles.
&#9;When it knows where each triangle should be, the GPU calculates which pixels each triangle contains. Then it runs another GLSL programme, called the fragment shader, on each pixel to determine what colour it should have.
@SG_ML_BLANKLINE
&#9;We will start by writing the vertex shader. The vertex shader should look like this
@SG_ML_WARN #version 310 es&#10;precision highp float;&#10;layout(std140, binding = 0) uniform SG_RI_builtin_{&#10;    float x;&#10;    float y;&#10;    float width;&#10;    float height;&#10;    float windowWidth;&#10;    float windowHeight;&#10;    int offscreen;&#10;} SG_RI_builtin;&#10;vec4 SG_RI_transform(vec4 prelimPosition){&#10;    prelimPosition = vec4(2.0f * (prelimPosition.x * SG_RI_builtin.width / SG_RI_builtin.windowWidth + SG_RI_builtin.x / SG_RI_builtin.windowWidth) - 1.0f, -2.0f * (prelimPosition.y * SG_RI_builtin.height / SG_RI_builtin.windowHeight + SG_RI_builtin.y / SG_RI_builtin.windowHeight) + 1.0f, prelimPosition.z, prelimPosition.w);&#10;    if(SG_RI_builtin.offscreen != 0){prelimPosition = vec4(prelimPosition.x, -1.0f * prelimPosition.y, prelimPosition.z, prelimPosition.w);}&#10;    return prelimPosition;&#10;}&#10;// declare your input and output variables here&#10;&#10;void main(){&#10;    // write the actual code here&#10;    gl_Position = SG_RI_transform(gl_Position);&#10;}
&#9;That looks really complicated...
&#9;All the code you see above is stuff that allows the rendered output to be moved inside the correct @SG_ML_L018015SGWidget ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/sgwidget, instead of filling the whole screen. It looks annoying, but you just have to copy paste the same thing for literally every single vertex shader.
&#9;All the code logic that you will write is only in the positions of the 2 comments you see in the code block above. The first comment is where you should declare input and output variables, and the second comment is where you write the actual code.
&#9;Input variables are sourced from the vertex buffer object. This must include the coordinates of the vertices of the triangles.
&#9;The output variables will be passed to the fragment shader. This can be used so that a pixel knows where it is inside the @SG_ML_L018015SGWidget ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/sgwidget.
&#9;Since the renderer that we are building just draws a rectangle with some colours on it, the vertex shader will do nothing except telling the GPU where the triangles should be and sending the coordinates to the fragment shader. The triangles will not be transformed.
&#9;We can replace the first commend with
@SG_ML_WARN layout(location = 0) in vec2 vertex;&#10;layout(location = 0) out vec2 vertexUnits;
&#9;This declares @SG_ML_B006vertex to be an input variable corresponding to the coordinates of a vertex of the triangle, and @SG_ML_B00BvertexUnits to be an output variable that will get sent to the fragment shader.
&#9;The layout(location = 0) before the declaration of @SG_ML_B006vertex means that @SG_ML_B006vertex will be found at location 0 of each vertex in the vertex buffer object.
&#9;The layout(location = 0) before the declaration of @SG_ML_B00BvertexUnits means that @SG_ML_B00BvertexUnits will be found at location 0 of the output of the vertex shader, so the fragment shader should take it from location 0 later.
&#9;We replace the second command with
@SG_ML_WARN gl_Position = vec4(vertex.x, vertex.y, 0.0f, 1.0f);&#10;vertexUnits = vertex;
&#9;Assigning to gl_Position tells the GPU that the triangle is found at whatever the input position is (so it should not be moved). When using SG - RI, the third and fourth coordinates must always be 0.0f and 1.0f, anything else is @SG_ML_L01301Fundefined behaviour../tutorials/undefinedbehaviour.
&#9;Setting @SG_ML_B00BvertexUnits to @SG_ML_B006vertex passes the same variable into the fragment shader where it will actually be used.
@SG_ML_BLANKLINE
&#9;Next we write the fragment shader to tell the GPU how exactly to colour the pixels.
@SG_ML_WARN #version 310 es&#10;precision highp float;&#10;layout(std140, binding = 0) uniform SG_RI_builtin_{&#10;    float x;&#10;    float y;&#10;    float width;&#10;    float height;&#10;    float windowWidth;&#10;    float windowHeight;&#10;    int offscreen;&#10;} SG_RI_builtin;&#10;layout(std140, binding = 1) uniform selection_{&#10;    float hue;&#10;    float saturation;&#10;    float lightness;&#10;    float transparency;&#10;    int type;&#10;} selection;&#10;layout(location = 0) in vec2 vertexUnits;&#10;layout(location = 0) out vec4 outColour;&#10;&#10;float computePQT(float p, float q, float t){&#10;	if(t &lt; 0.0){t += 1.0;}&#10;    else if(t &gt; 1.0){t -= 1.0;}&#10;    if(t &lt; 1.0 / 6.0){return (p + 6.0 * t * (q - p));}&#10;    if(t &lt; 0.5){return q;}&#10;    if(t &lt; 2.0 / 3.0){return (p + 6.0 * (2.0 / 3.0 - t) * (q - p));}&#10;    return p;&#10;}&#10;&#10;vec4 getRGB(float xh, float xs, float xl, float xa){&#10;	float r = 0.0;&#10;	float g = 0.0;&#10;	float b = 0.0;&#10;	if(xs == 0.0){&#10;        r = xl;&#10;        g = xl;&#10;        b = xl;&#10;    }&#10;    else{&#10;        float q = 0.0;&#10;        if(xl &lt; 0.5){q = xl * (1.0 + xs);}&#10;        else{q = xl + xs - xl * xs;}&#10;        float p = 2.0 * xl - q;&#10;        r = computePQT(p, q, xh + 1.0 / 3.0);&#10;        g = computePQT(p, q, xh);&#10;        b = computePQT(p, q, xh - 1.0 / 3.0);&#10;    }&#10;	return vec4(r, g, b, xa);&#10;}&#10;&#10;void main(){&#10;    float zeroPointTwo = 0.2f * SG_RI_builtin.height / SG_RI_builtin.width;&#10;    float selectPoint = 0.0f;&#10;    bool addTransparencyGrid = false;&#10;    if(selection.type == 1){selectPoint = selection.hue;}&#10;    else if(selection.type == 2){selectPoint = selection.saturation;}&#10;    else if(selection.type == 3){selectPoint = selection.lightness;}&#10;    else if(selection.type == 4){selectPoint = selection.transparency;}&#10;    if(0.5f * (1.0f - vertexUnits.y) + abs(vertexUnits.x - (zeroPointTwo + selectPoint * (1.0f - 2.0f * zeroPointTwo))) * SG_RI_builtin.width / SG_RI_builtin.height &lt; 0.2f){&#10;        if(selection.type == 1){outColour = getRGB(selection.hue, 1.0f, 0.5f, 1.0f);}&#10;        else if(selection.type == 2){outColour = getRGB(selection.hue, selection.saturation, 0.5f, 1.0f);}&#10;        else if(selection.type == 3){outColour = getRGB(selection.hue, selection.saturation, selection.lightness, 1.0f);}&#10;        else if(selection.type == 4){&#10;            outColour = getRGB(selection.hue, selection.saturation, selection.lightness, selection.transparency);&#10;            addTransparencyGrid = true;&#10;        }&#10;    }&#10;    else if(vertexUnits.y &lt;= 0.8f && vertexUnits.x &gt; zeroPointTwo && vertexUnits.x &lt; 1.0f - zeroPointTwo){&#10;        float x = (vertexUnits.x - zeroPointTwo) / (1.0f - 2.0f * zeroPointTwo);&#10;        if(selection.type == 1){outColour = getRGB(x, 1.0f, 0.5f, 1.0f);}&#10;        else if(selection.type == 2){outColour = getRGB(selection.hue, x, 0.5f, 1.0f);}&#10;        else if(selection.type == 3){outColour = getRGB(selection.hue, selection.saturation, x, 1.0f);}&#10;        else if(selection.type == 4){&#10;            outColour = getRGB(selection.hue, selection.saturation, selection.lightness, x);&#10;            addTransparencyGrid = true;&#10;        }&#10;    }&#10;    else{outColour = vec4(1.0f, 1.0f, 1.0f, 1.0f);}&#10;    if(addTransparencyGrid == true){&#10;        float intensity = 0.8f + 0.15f * float((int(5.0f * vertexUnits.x * SG_RI_builtin.width / SG_RI_builtin.height) + int(5.0f * vertexUnits.y)) % 2);&#10;        outColour = vec4(outColour.a * outColour.r + (1.0f - outColour.a) * intensity, outColour.a * outColour.g + (1.0f - outColour.a) * intensity, outColour.a * outColour.b + (1.0f - outColour.a) * intensity, 1.0f);&#10;    }&#10;}
&#9;All this code determines how the pixels are actually coloured, that is why it is so long.
&#9;Pay special attention to this part
@SG_ML_WARN layout(location = 0) in vec2 vertexUnits;&#10;layout(location = 0) out vec4 outColour;
&#9;We declare a output variable that is a vec4. All fragment shaders should have exactly 1 output variable with type being vec4 at location 0, this is the colour that will be drawn to the corresponding pixels on the screen.
&#9;Also note how the name, type, and location of @SG_ML_B00BvertexUnits matches the output variable @SG_ML_B00BvertexUnits from the vertex shader. This allows the vertex shader output to be passed into the fragment shader correctly.
&#9;These are uniform buffer objects.
@SG_ML_WARN layout(std140, binding = 0) uniform SG_RI_builtin_{&#10;    float x;&#10;    float y;&#10;    float width;&#10;    float height;&#10;    float windowWidth;&#10;    float windowHeight;&#10;    int offscreen;&#10;} SG_RI_builtin;&#10;layout(std140, binding = 1) uniform selection_{&#10;    float hue;&#10;    float saturation;&#10;    float lightness;&#10;    float transparency;&#10;    int type;&#10;} selection;
&#9;We have a uniform buffer object at binding point 0 called @SG_ML_B00DSG_RI_builtin and another one at binding point 1 called @SG_ML_B009selection.
&#9;The binding point indicates the location of the uniform buffer object.
&#9;The @SG_ML_B00DSG_RI_builtin uniform buffer object must always be present and declared in exactly that form. @SG_ML_B009selection is our custom uniform buffer object which we can use to pass data to the shader.
@SG_ML_BLANKLINE
&#9;Now that we have our shaders ready, we can add them to our project. For more information about this step, you can see @SG_ML_L009007this linkshaders, but here is the CMake commands.
@SG_ML_WARN qt6_add_shaders(SG_RI SG_RI_shaders PREFIX "SGEXTN" BASE "SG_RI/assets" FILES&#10;    "SG_RI/assets/colourpicker.vert"&#10;    "SG_RI/assets/colourpicker.frag"&#10;)
&#9;This assumes that your vertex shader is at path SG_RI/assets/colourpicker.vert and your fragment shader is at path SG_RI/assets/colourpicker.frag
&#9;After doing these, the shaders will be automatically compiled by QSB and you can access the compiled shaders at :/SGEXTN/colourpicker.vert.qsb and :/SGEXTN/colourpicker.frag.qsb respectively.
@SG_ML_BLANKLINE
&#9;Finally we can work on the C++ side.
&#9;We will need a renderer that uses GPU commands, and a syncer that sends information to the renderer. The renderer runs on a separate thread and it is not allowed to directly use information outside its thread, since that will cause data race.
&#9;Our header file should look like this
@SG_ML_WARN class SGRColourPickerRenderer : public SGRBaseRenderer&#10;{&#10;public:&#10;    SGRColourPickerRenderer(int type);&#10;    int type;&#10;    float hue;&#10;    float saturation;&#10;    float lightness;&#10;    float transparency;&#10;    SGRRenderingProgramme* createRenderingProgramme() override;&#10;    void initialise() override;&#10;    void cleanResourcesOnDestruction() override;&#10;    void uploadShaderData() override;&#10;    void requestRenderCommands(SGRCommandRequest* commandRequest) override;&#10;    SGRVertexBufferObject* vbo;&#10;    SGRElementBufferObject* ebo;&#10;};
&#9;A few things to take note here
&#9;The renderer must inherit from @SG_ML_L00F01BSGRBaseRenderer../cppclass/sgrbaserenderer, because @SG_ML_L00F01BSGRBaseRenderer../cppclass/sgrbaserenderer provides everything necessary to render. It also must implement all pure virtual functions in @SG_ML_L00F01BSGRBaseRenderer../cppclass/sgrbaserenderer.
&#9;The renderer manages its on @SG_ML_L015021SGRVertexBufferObject../cppclass/sgrvertexbufferobject and @SG_ML_L016022SGRElementBufferObject../cppclass/sgrelementbufferobject. These are the vertex buffer object, and the element buffer object which tells the GPU which vertices to use for each triangle.
&#9;Also, the renderer contains its own data. This data is stored on the renderer's thread and can be safely accessed by it whenever necessary. The syncer syncs this data with what it should be on every frame.
&#9;And the code for the syncer
@SG_ML_WARN class SGRColourPickerSyncer : public SGRBaseSyncer&#10;{&#10;public:&#10;    SGRColourPickerSyncer();&#10;    float hue;&#10;    float saturation;&#10;    float lightness;&#10;    float transparency;&#10;    void sync(SGRBaseRenderer* renderControl) override;&#10;};
&#9;Just like how the renderer must inherit from @SG_ML_L00F01BSGRBaseRenderer../cppclass/sgrbaserenderer, the syncer must inherit from @SG_ML_L00D019SGRBaseSyncer../cppclass/sgrbasesyncer and implement its pure virtual functions.
&#9;The syncer also keeps its own copy of all the variables. This copy can be freely read from and written to by other parts of the programme at any time, since it is on the main thread.
@SG_ML_BLANKLINE
&#9;Next we can work on implementing everything.
&#9;Here you will see how much easier it is to work with SG - RI as compared to other graphics frameworks.
&#9;First, the constructor of the renderer.
@SG_ML_WARN SGRColourPickerRenderer::SGRColourPickerRenderer(int type){&#10;    (*this).type = type;&#10;    (*this).hue = 0.0f;&#10;    (*this).saturation = 0.0f;&#10;    (*this).lightness = 0.0f;&#10;    (*this).transparency = 0.0f;&#10;    (*this).vbo = nullptr;&#10;    (*this).ebo = nullptr;&#10;}
&#9;This does nothing, because the renderer is created before anything GPU side even starts to set up. The actual setting up process is done in the implementation of @SG_ML_L01B040SGRBaseRenderer::initialise../cppclass/sgrbaserenderer#virtual_void_initialise_func_assign_.
@SG_ML_BLANKLINE
&#9;Then we implement @SG_ML_L029063SGRBaseRenderer::createRenderingProgramme../cppclass/sgrbaserenderer#virtual_SGRRenderingProgramme_ptr_createRenderingProgramme_func_assign_. This creates a @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme which can tell the GPU what to do.
@SG_ML_WARN SGRRenderingProgramme* SGRColourPickerRenderer::createRenderingProgramme(){&#10;    SGRRenderingProgramme* rp = new SGRRenderingProgramme(this);&#10;    (*rp).setShaderQSBFiles(":/SGEXTN/colourpicker.vert.qsb", ":/SGEXTN/colourpicker.frag.qsb");&#10;    (*rp).addUniformBufferObject(20, 1);&#10;    (*rp).finaliseShaderResource();&#10;    (*rp).addVertexBufferObject(2 * 4);&#10;    (*rp).addVertexProperty(0, 0, 0, SGRGraphicsLanguageType::Float, 2);&#10;    (*rp).finaliseVertices();&#10;    (*rp).finaliseRenderingProgramme();&#10;    return rp;&#10;}
&#9;Normally, this step is extremely complicated, but in SG - RI, it is much simpler.
&#9;We first create a @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme called rp. A pointer to the renderer is passed to indicate which renderer the @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme is associated with.
&#9;Then we set the shader files. This step tells the @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme what vertex shader and fragment shader it should use.
&#9;After that, we add a uniform buffer object using @SG_ML_L02D04CSGRRenderingProgramme::addUniformBufferObject../cppclass/sgrrenderingprogramme#void_addUniformBufferObject_int_int_const_ with a size of 20 bytes and binding point 1. This is @SG_ML_B009selection which we declared earlier in the fragment shader. Note how the binding point matches.
&#9;The length of a uniform buffer object depends on what it contains and can be calculated using std140 alignment rules. If you are not passing any vectors, the rules just say that the length is the sum of everything you use and they should be packed tightly in order of declaration. In our case, 4 floating point numbers and 1 int sum to 20 bytes.
&#9;Since we only need 1 uniform buffer object and no textures, we can call @SG_ML_L02D043SGRRenderingProgramme::finaliseShaderResource../cppclass/sgrrenderingprogramme#void_finaliseShaderResource_func_ after adding the uniform buffer object.
&#9;Then we add a vertex buffer object with a size of 8 bytes per vertex. SG - RI allows you to add many vertex buffer objects that can each contain a different part of the vertex, but here we only need 1.
&#9;The size per vertex must match the size of all input variables that the vertex shader receives. In our case, it is a vec2, or 2 floats, giving a length of 8 bytes.
&#9;We then use @SG_ML_L02806FSGRRenderingProgramme::addVertexProperty../cppclass/sgrrenderingprogramme#void_addVertexProperty_int_int_int_SGRGraphicsLanguageType_mc_Type_int_const_ on the vertex shader input variable to register it. This tells the GPU where the variable can be found (both vertex shader number and offset), which location of the vertex shader input it should be placed, and the type of the variable. In our case, the data should be sourced from offset 0 of each vertex in vertex buffer object number 0. The data need to be placed at location 0 of the vertex shader, and it is 2 floating point numbers.
&#9;Since that is all inputs we need to the vertex shader, we can call @SG_ML_L02703DSGRRenderingProgramme::finaliseVertices../cppclass/sgrrenderingprogramme#void_finaliseVertices_func_. After that we call @SG_ML_L031047SGRRenderingProgramme::finaliseRenderingProgramme../cppclass/sgrrenderingprogramme#void_finaliseRenderingProgramme_func_ because we have done setting up the @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme.
&#9;If you are familiar with graphics terminology, this process is setting up the rendering pipeline. Note how it is so much simpler in SG - RI compared to any other graphics framework.
@SG_ML_BLANKLINE
&#9;Our next step is to set up the vertex buffer object and element buffer object.
@SG_ML_WARN void SGRColourPickerRenderer::initialise(){&#10;    vbo = new SGRVertexBufferObject(this, 4 * 2 * 4);&#10;    SGLArray&lt;float&gt; vt(0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);&#10;    (*renderingProgramme()).updateDataBuffer(vbo, 0, 4 * 2 * 4, vt.pointerToData(0));&#10;    ebo = new SGRElementBufferObject(this, 2 * 3 * 4);&#10;    SGLArray&lt;int&gt; et(0, 1, 2, 1, 2, 3);&#10;    (*renderingProgramme()).updateDataBuffer(ebo, 0, 2 * 3 * 4, et.pointerToData(0));&#10;}
&#9;We create a @SG_ML_L015021SGRVertexBufferObject../cppclass/sgrvertexbufferobject linked to the renderer and with a size of 4 (number of vertices) x 2 (floats per vertex) x 4 (bytes per float) bytes.
&#9;We then create the data to be put into the vertex array buffer, this is (0, 0), (1, 0), (0, 1), (1, 1). The x and y coordinates are relative to the @SG_ML_L018015SGWidget ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/sgwidget (or more specifically, the @SG_ML_L01101DSGRRendererWidget../cppclass/sgrrendererwidget) using this renderer. (0, 0) is the top left corner and (1, 1) is the bottom right corner.
&#9;We use @SG_ML_L027061SGRRenderingProgramme::updateDataBuffer../cppclass/sgrrenderingprogramme#void_updateDataBuffer_SGRDataBuffer_ptr_int_int_void_ptr_const_ to upload the data, both @SG_ML_L015021SGRVertexBufferObject../cppclass/sgrvertexbufferobject and @SG_ML_L016022SGRElementBufferObject../cppclass/sgrelementbufferobject inherit from @SG_ML_L00D019SGRDataBuffer../cppclass/sgrdatabuffer so they fit in the argument. A pointer to the @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme being used can be gotten from @SG_ML_L02305ESGRBaseRenderer::renderingProgramme../cppclass/sgrbaserenderer#nodiscard_SGRRenderingProgramme_ptr_renderingProgramme_func_const_.
&#9;Similarly, we create a element buffer object with 2 (number of triangles) x 3 (vertices per triangle) x 4 (bytes per integer) bytes to store information about how the vertices should be used. We write in 0, 1, 2, 1, 2, 3, which means that a triangle should use vertices 0, 1, 2 and the other should use vertices 1, 2, 3.
&#9;When the triangles are combined, they form a rectangle that covers the area of the associated @SG_ML_L018015SGWidget ⁽㈳㈴㈳㈮㈱㈨㈠㈫ ㈧㈤㈱㈤⁾../tutorials/sgwidget perfectly. This is called a fullscreen quad.
@SG_ML_BLANKLINE
&#9;Next we define how to clean up when the renderer is deleted. Since the only parts that we own is the vertex buffer object and element buffer object, we just delete these.
@SG_ML_WARN void SGRColourPickerRenderer::cleanResourcesOnDestruction(){&#10;    delete vbo;&#10;    delete ebo;&#10;}
&#9;The @SG_ML_L015021SGRRenderingProgramme../cppclass/sgrrenderingprogramme is managed internally by SG - RI and will be deleted automatically. Freeing of GPU side memory is also done automatically.
@SG_ML_BLANKLINE
&#9;Then we can tell the GPU how to update the uniform buffer objects. @SG_ML_B00DSG_RI_builtin is updated automatically so you do not need to worry about that.
&#9;To update @SG_ML_B009selection, we do this
@SG_ML_WARN void SGRColourPickerRenderer::uploadShaderData(){&#10;    SGLArray&lt;float&gt; ut(hue, saturation, lightness, transparency);&#10;    (*renderingProgramme()).updateShaderUniforms(1, 0, 16, ut.pointerToData(0));&#10;    (*renderingProgramme()).updateShaderUniforms(1, 16, 4, &type);&#10;}
&#9;Note how the binding point of 1 passed to @SG_ML_L02B057SGRRenderingProgramme::updateShaderUniforms../cppclass/sgrrenderingprogramme#void_updateShaderUniforms_int_int_int_void_ptr_const_ matches the binding point 1 of @SG_ML_B009selection as declared in the fragment shader.
&#9;Also note how in the first call, we write bytes 0 - 15, and in the second call, we write bytes 16 - 19, filling up all 20 allocated bytes that we declared to be the length of the uniform buffer object.
@SG_ML_BLANKLINE
&#9;Finally, time to actually draw stuff on the screen.
@SG_ML_WARN void SGRColourPickerRenderer::requestRenderCommands(SGRCommandRequest *commandRequest){&#10;    (*commandRequest).addVertexBufferObject(vbo, 0);&#10;    (*commandRequest).chooseElementBufferObject(ebo);&#10;    (*commandRequest).finaliseForDraw();&#10;    (*commandRequest).drawTriangles(2, 0);&#10;}
&#9;This makes a draw call. On every frame, we must rebind the vertex buffer objects and element buffer object. After binding everything, we need to call @SG_ML_L022038SGRCommandRequest::finaliseForDraw../cppclass/sgrcommandrequest#void_finaliseForDraw_func_ before using @SG_ML_L02003FSGRCommandRequest::drawTriangles../cppclass/sgrcommandrequest#void_drawTriangles_int_int_const_ to actually draw the triangles.
&#9;Note that the 2 passed to @SG_ML_L02003FSGRCommandRequest::drawTriangles../cppclass/sgrcommandrequest#void_drawTriangles_int_int_const_ is the number of triangles, not number of vertices, to draw. SG - RI only supports drawing triangles.
@SG_ML_BLANKLINE
&#9;We only have the syncer remaining to implement. Similar to the renderer, it is created before anything on the GPU happens, so its constructor does nothing.
@SG_ML_WARN SGRColourPickerSyncer::SGRColourPickerSyncer(){&#10;    (*this).hue = 0.0f;&#10;    (*this).saturation = 0.0f;&#10;    (*this).lightness = 0.0f;&#10;    (*this).transparency = 0.0f;&#10;}
&#9;In @SG_ML_L013047SGRBaseSyncer::sync../cppclass/sgrbasesyncer#virtual_void_sync_SGRBaseRenderer_ptr_assign_, we simply copy over the data. This is the only safe point where data can be exchanged between the renderer and the syncer.
@SG_ML_WARN void SGRColourPickerSyncer::sync(SGRBaseRenderer *renderControl){&#10;    SGRColourPickerRenderer* rc = static_cast&lt;SGRColourPickerRenderer*&gt;(renderControl);&#10;    (*rc).hue = hue;&#10;    (*rc).saturation = saturation;&#10;    (*rc).lightness = lightness;&#10;    (*rc).transparency = transparency;&#10;}
&#9;And we are done.
@SG_ML_BLANKLINE
&#9;To use the custom renderer, we simply create a @SG_ML_L01101DSGRRendererWidget../cppclass/sgrrendererwidget containing it.
@SG_ML_WARN SGRColourPickerSyncer* syncer = new SGRColourPickerSyncer();&#10;new SGRRendererWidget(realBg, 0.0f, 0.5f, 0.0f, 0.5f, 1.0f, -1.0f, 0.0f, 1.25f, new SGRColourPickerRenderer(1), SGWColourPicker::hueSync);
&#9;Remember to keep a pointer to the syncer so that you can update the information to be synced each frame. After updating the information, call @SG_ML_L027043SGRRendererWidget::updateCustomRenderer../cppclass/sgrrendererwidget#void_updateCustomRenderer_func_const_ to redraw.
&#9;
