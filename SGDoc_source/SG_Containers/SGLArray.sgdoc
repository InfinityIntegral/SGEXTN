@SG_CPP_CLASS SGLArray
@SG_SHORT_DESCRP variable length array for any type of data
@SG_LONG_DESCRP SGLArray provides a template based array data structure to store any type of data. This is similar to C arrays and different from C++'s std::array as the size does not need to be a compile time constant. @SG_FINDREP_HEADER_ONLY @SG_FINDREP_CONTAINER_CAN_COPY_MOVE @SG_FINDREP_CONTENTS_CAN_COPY_MOVE
@SG_IMPLE SGLArray internally maintains a C array stored on the heap.
@SG_FUNC SGLArray(int count);
Creates a SGLArray of size $count, with every element default initialised.
@SG_WARN The type stored in the SGLArray must have a default constructor (the one taking no arguments) for this to compile.
@SG_WARN You must ensure that $count is nonnegative. Negative $count results in undefined behaviour.
@SG_FUNC SGLArray(int count, const T& defaultValue);
Creates a SGLArray of size $count, with every element initialised to $defaultValue.
@SG_WARN You must ensure that $count is nonnegative. Negative $count results in undefined behaviour.
@SG_FUNC template <typename... Ts> SGLArray(Ts... data);
SGLArray does not support initialisation using initialiser lists. This is the closest that you can get to using a initialiser list.
This constructor of SGLArray takes a variable number of arguments corresponding to what the data inside should be set to. The length of the SGLArray is determined automatically from the number of arguments passed.
SGLArray<int>(1, 2, 3, 4, 5) will create a SGLArray<int> with contents [1, 2, 3, 4, 5]
@SG_NOTE The arguments to this constructor must be within a pair of parentheses, not braces. This is NOT a initialiser list.
@SG_WARN This constructor has lower function overload resolution priority than any other constructor. When using this to initialise a SGLArray containing 1 or 2 numerical data types, ensure that this does not resolve to another constructor unintentionally.
@SG_FUNC void assign(int count, const T& defaultValue);
Assigns a SGLArray($count, $defaultValue) to this SGLArray.
@SG_NOTE arr.assign($count, $defaultValue); is identical in functionality to arr = SGLArray<T>($count, $defaultValue); Choosing one over the other is purely coding style.
@SG_WARN You must ensure that $count is nonnegative. Negative $count results in undefined behaviour.
@SG_FUNC void fill(const T& defaultValue);
Sets every element in the existing SGLArray to $defaultValue without resizing the SGLArray.
@SG_NOTE If the SGLArray may need to be resized, use SGLArray::assign instead.
@SG_FUNC [[nodiscard]] int length() const;
Returns the length of the SGLArray, which is the number of elements stored inside it.
@SG_NOTE Unless assigned to or if SGLArray::assign is used, this always stays the same after the SGLArray is created.
@SG_FUNC [[nodiscard]] T& at(int i);
Returns a reference to element $i of the SGLArray.
@SG_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the SGLArray.
@SG_WARN This crashes for out of bounds $i.
@SG_FUNC [[nodiscard]] const T& at(int i) const;
Returns a constant reference to element $i of the SGLArray.
@SG_WARN This crashes for out of bounds $i.
@SG_FUNC [[nodiscard]] T* pointerToData(int n);
Returns a pointer to element $n of the SGLArray. This does not dereference the returned pointer.
@SG_NOTE Using an out of bounds value for $n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for $n may be used intentionally to specify parts of the SGLArray to run SGLSort on.
@SG_NOTE The returned value may function as an iterator.
@SG_NOTE Assigning to the dereferenced value from the returned pointer would modify the SGLArray
@SG_WARN Dereferencing the returned pointer when $n is out of bounds results in undefined behaviour.
@SG_FUNC [[nodiscard]] const T* pointerToData(int n) const;
Returns a read only pointer to element $n of the SGLArray. This does not dereference the returned pointer.
@SG_NOTE Using an out of bounds value for $n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for $n may be used intentionally to specify parts of the SGLArray to run SGLSort on.
@SG_NOTE The returned value may function as an iterator.
@SG_WARN Dereferencing the returned pointer when $n is out of bounds results in undefined behaviour.
@SG_PRIVATE_API T* dataInternal;
@SG_PRIVATE_API int lengthInternal;
