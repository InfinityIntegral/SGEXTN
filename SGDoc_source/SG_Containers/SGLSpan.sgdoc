@SG_CPP_CLASS SGLSpan
@SG_SHORT_DESCRP span for any type of data
@SG_LONG_DESCRP SGLSpan provides a template based span that can be used with any data type. SGLSpan does not own the data that it allows access to. Deleting heap data accessed through SGLSpan is undefined behaviour in the form of double delete. @SG_FINDREP_HEADER_ONLY
@SG_IMPLE SGLSpan stores a pointer to the start of the span and the number of elements in the span.
@SG_FUNC SGLSpan(T* dataInternal, int lengthInternal);
Creates a SGLSpan starting from $dataInternal with a length of $lengthInternal.
@SG_WARN Negative $lengthInternal will cause a crash.
@SG_WARN $dataInternal being nullptr will cause a crash.
@SG_WARN If any memory between $dataInternal (inclusive) and $dataInternal + $lengthInternal (exclusive) is not allocated, have been deleted, or if the 2 endpoints come from different data structures, creating the span is undefined behaviour.
@SG_WARN Using the span in any way after the host data structure is deleted is undefined behaviour
@SG_WARN To avoid undefined behaviour, do not allocate any SGLSpan on the heap.
@SG_FUNC [[nodiscard]] int length() const;
Returns the length of the SGLSpan.
@SG_NOTE This is constant after the creation of the SGLSpan.
@SG_FUNC [[nodiscard]] T& at(int i);
Returns a reference to the element at index $i of the SGLSpan.
@SG_NOTE This returns a reference and not a copy. Assigning to the returned value (using it as a lvalue) modifies the host data structure.
@SG_WARN If $i is out of bounds, this causes a crash.
@SG_FUNC [[nodiscard]] const T& at(int i) const;
Returns a constant reference to the element at index $i of the SGLSpan.
@SG_WARN If $i is out of bounds, this causes a crash.
@SG_FUNC [[nodiscard]] SGLSpan subspan(int start, int length) const;
Returns a subspan starting at index $start of the original span with a length of $length.
@SG_WARN Negative $length will crash.
@SG_WARN If $start or $start + $length - 1 is out of bounds, this will crash.
@SG_FUNC [[nodiscard]] SGLSpan subspanLeft(int length) const;
Returns a subspan containing the first $length elements of the original span.
@SG_WARN Negative $length will crash.
@SG_WARN If $length is greater than the length of the span, this will crash.
@SG_FUNC [[nodiscard]] SGLSpan subspanRight(int length) const;
Returns a subspan containing the last $length elements of the original span.
@SG_WARN Negative $length will crash.
@SG_WARN If $length is greater than the length of the span, this will crash.
@SG_FUNC [[nodiscard]] T* pointerToData(int n);
Returns a pointer to the element at index $n of the original span.
@SG_NOTE It is ok for $n to be out of bounds as long as the returned pointer is not dereferenced. This can be done intentionally to define bounds for SGLSort.
@SG_NOTE The returned value may function as an iterator.
@SG_WARN Dereferencing the returned pointer when $n is out of bounds is undefined behaviour.
@SG_FUNC [[nodiscard]] const T* pointerToData(int n) const;
Returns a read only pointer to the element at index $n of the original span.
@SG_NOTE It is ok for $n to be out of bounds as long as the returned pointer is not dereferenced. This can be done intentionally to define bounds for SGLSort.
@SG_NOTE The returned value may function as an iterator.
@SG_WARN Dereferencing the returned pointer when $n is out of bounds is undefined behaviour.
@SG_PRIVATE_API T* dataInternal;
@SG_PRIVATE_API int lengthInternal;
