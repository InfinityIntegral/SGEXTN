@SG_CPP_CLASS SGLDeque
@SG_SHORT_DESCRP double ended queue for any type of data
@SG_LONG_DESCRP SGLDeque provides a template based double queue, an array-like data structure that you can freely insert elements at and remove elements from both ends, in addition to randomly reading from and writing to elements by their index. If only queue or stack behaviour is needed, pls use SGLQueue or SGLStack instead for better readability and performance. @SG_FINDREP_HEADER_ONLY @SG_FINDREP_CONTAINER_CAN_COPY_MOVE @SG_FINDREP_CONTENTS_CAN_COPY_MOVE
@SG_IMPLE SGLDeque internally stores a buffer in the form of a C array. Elements are placed into the buffer starting at approximately a third of the buffer's length and the start point and end point of the data is kept track of. Insertion at both ends expand the section of the buffer being used. If there is no more space for the buffer to expand, the buffer triples in size and all elements are shifted to align with the 1/3 mark.
@SG_FUNC SGLDeque();
Creates a SGLDeque containing no elements.
@SG_FUNC SGLDeque(int count);
Creates a SGLDeque containing $count elements which are default initialised.
@SG_WARN The type stored in the SGLDeque must have a default constructor (the one taking no arguments) for this to compile.
@SG_WARN You must ensure that $count is nonnegative. Negative $count results in undefined behaviour.
@SG_FUNC SGLDeque(int count, const T& defaultValue);
Creates a SGLDeque containing $count copies of $defaultValue.
@SG_WARN You must ensure that $count is nonnegative. Negative $count results in undefined behaviour.
@SG_FUNC void assign(int count, const T& defaultValue);
Resets the SGLDeque to have $count copies of $defaultValue.
dq.assign($count, $defaultValue); is functionally identical to dq = SGLDeque<T>($count, $defaultValue);
@SG_WARN You must ensure that $count is nonnegative. Negative $count results in undefined behaviour.
@SG_FUNC void fill(const T& defaultValue);
Sets every element in the SGLDeque to $defaultValue. This does not resize the SGLDeque.
@SG_NOTE If the SGLDeque needs to be resized, use SGLDeque::assign.
@SG_FUNC [[nodiscard]] T& at(int i);
Returns a reference to element $i of the SGLDeque.
@SG_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the SGLDeque.
@SG_WARN This crashes for out of bounds $i.
@SG_FUNC [[nodiscard]] const T& at(int i) const;
Returns a constant reference to element $i of the SGLDeque.
@SG_WARN This crashes for out of bounds $i.
@SG_FUNC [[nodiscard]] const T& front() const;
Returns a constant reference to the first element of SGLDeque.
@SG_NOTE dq.front() has the same effect as dq.at(0)
@SG_NOTE Use SGLDeque::at if the element needs to be modified.
@SG_WARN If the SGLDeque has a size of 0, accessing SGLDeque::front is undefined behaviour.
@SG_FUNC [[nodiscard]] const T& back() const;
Returns a constant reference to the last element of SGLDeque.
@SG_NOTE dq.back() has the same effect as dq.at(dq.length() - 1)
@SG_NOTE Use SGLDeque::at if the element needs to be modified.
@SG_WARN If the SGLDeque has a size of 0, accessing SGLDeque::back is undefined behaviour.
@SG_FUNC [[nodiscard]] int length() const;
Returns the length of the SGLDeque, which is the number of elements currently stored inside it.
@SG_FUNC void pushBack(const T& x);
Appends $x at the end of the SGLDeque.
@SG_NOTE This runs in amortised O(1) per use. To make it run in truly constant time, use SGLDeque::reserve to pre allocate the internal memory buffer with 3 times the required memory.
@SG_FUNC void popBack();
Removes the last element of the SGLDeque.
@SG_NOTE This runs in truly constant time.
@SG_NOTE This does not return the last element. If you need the last element, access it with SGLDeque::back before running this.
@SG_WARN Running SGLDeque::popBack on an empty SGLDeque is undefined behaviour.
@SG_FUNC void pushFront(const T& x);
Prepends $x at the start of the SGLDeque.
@SG_NOTE This runs in amortised O(1) per use. To make it run in truly constant time, use SGLDeque::reserve to pre allocate the internal memory buffer with 3 times the required memory.
@SG_FUNC void popFront();
Removes the first element of the SGLDeque.
@SG_NOTE This runs in truly constant time.
@SG_NOTE This does not return the first element. If you need the first element, access it with SGLDeque::front before running this.
@SG_WARN Running SGLDeque::popFront on an empty SGLDeque is undefined behaviour.
@SG_FUNC void reserve(int newMemoryLength);
Pre allocates the internal memory buffer to a size sufficient to store $newMemoryLength elements in the SGLDeque.
@SG_NOTE Pre allocate 3 times the required memory to avoid resizing. This is only necessary for SGLDeque and not SGLVector as only SGLDeque permits insertion on both ends.
@SG_NOTE If the internal memory buffer is larger than the requested length, nothing is done.
@SG_FUNC [[nodiscard]] T* pointerToData(int n);
Returns a pointer to element $n of the SGLDeque. This does not dereference the returned pointer.
@SG_NOTE Using an out of bounds value for $n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for $n may be used intentionally to specify parts of the SGLDeque to run SGLSort on.
@SG_NOTE The returned value may function as an iterator.
@SG_NOTE Assigning to the dereferenced value from the returned pointer would modify the SGLDeque.
@SG_WARN Dereferencing the returned pointer when $n is out of bounds results in undefined behaviour.
@SG_FUNC [[nodiscard]] const T* pointerToData(int n) const;
Returns a read only pointer to element $n of the SGLDeque. This does not dereference the returned pointer.
@SG_NOTE Using an out of bounds value for $n is ok for this function as long as the returned pointer is not dereferenced. Out of bounds values for $n may be used intentionally to specify parts of the SGLDeque to run SGLSort on.
@SG_NOTE The returned value may function as an iterator.
@SG_WARN Dereferencing the returned pointer when $n is out of bounds results in undefined behaviour.
@SG_PRIVATE_API T* dataInternal;
@SG_PRIVATE_API int startInternal;
@SG_PRIVATE_API int endInternal;
@SG_PRIVATE_API int memoryLengthInternal;
