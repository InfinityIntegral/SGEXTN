@SG_CPP_CLASS SGLUnorderedMap
@SG_SHORT_DESCRP unordered map for any type of data
@SG_LONG_DESCRP SGLUnorderedMap provides a template based unordered map that can be used with any data type. Use SGLMap instead if ordering matters. SGEXTN does not provide any unordered multimap so you must use a SGLMap<K, SGLVector<V>>. @SG_FINDREP_HEADER_ONLY @SG_FINDREP_CONTAINER_CAN_COPY_MOVE @SG_FINDREP_CONTENTS_CAN_COPY_MOVE
@SG_IMPLE SGLUnorderedMap maintains an open addressed linear probing hash table with a load factor of 0.33 Due to the extremely low load factor, SGLUnorderedMap is much faster than most implementations of unordered map (especially the Standard Template Library one, which is not even open addressed) at the cost of higher memory usage. The hash table is stored in a C array memory buffer that triples in size when the load factor is reached.
@SG_PRIVATE_API Slot* dataInternal;
@SG_PRIVATE_API int lengthInternal;
@SG_PRIVATE_API int memoryUsedInternal;
@SG_PRIVATE_API int memoryLengthInternal;
@SG_PRIVATE_API EqualityCheck equalityCheckInstance;
@SG_PRIVATE_API HashFunction hashFunctionInstance;
@SG_PRIVATE_API void rehash(const K& xKey, const V& xValue);
@SG_FUNC SGLUnorderedMap();
Creates an empty SGLUnorderedMap.
@SG_FUNC [[nodiscard]] int length() const;
Returns the length of the SGLUnorderedMap, which is the number of key value pairs currently stored inside it.
@SG_FUNC void reserve(int newMemoryLength);
Pre allocates enough space for ($newMemoryLength / 3) - 1 elements to be stored in the SGLUnorderedMap without exceeding the load factor.
@SG_NOTE If there is already sufficient memory allocated, this is ignored.
@SG_FUNC void insert(const K& xKey, const V& xValue);
Inserts the key value pair ($xKey, $xValue) into the SGLUnorderedMap.
@SG_WARN If $xKey already exists in the SGLUnorderedMap, this will crash. If you cannot guarantee that the SGLUnorderedMap does not already contain the key, use SGLUnorderedMap::contains to check before insertion. This is a intentional design choice to avoid silent bugs.
@SG_FUNC void erase(const K& x);
Removes the key $x and its associated value from the SGLUnorderedMap.
@SG_WARN If $x is not in the SGLUnorderedMap, this will crash. If you cannot guarantee that the SGLUnorderedMap already contains the key, use SGLUnorderedMap::contains to check before removal. This is a intentional design choice to avoid silent bugs.
@SG_FUNC [[nodiscard]] bool contains(const K& x) const;
Returns if the SGLUnorderedMap contains $x as a key
@SG_FUNC [[nodiscard]] int count(const K& x) const;
Returns the number of copies of the key $x is found inside the SGLMap.
@SG_NOTE This is either 0 or 1, functionally identical to SGLUnorderedMap::contains. It is provided purely for API consistency.
@SG_FUNC [[nodiscard]] V& at(const K& x);
Returns a reference to the value associated with key $x in the SGLUnorderedMap.
@SG_NOTE Since this returns a reference and not a copy, assigning to it directly (using it as a lvalue) would modify the SGLUnorderedMap.
@SG_WARN This crashes if $x is not in the SGLUnorderedMap. Use SGLUnorderedMap::contains to check if $x is in the SGLUnorderedMap if unsure.
@SG_FUNC [[nodiscard]] const V& at(const K &x) const;
Returns a constant reference to the value associated with key $x in the SGLUnorderedMap.
@SG_WARN This crashes if $x is not in the SGLUnorderedMap. Use SGLUnorderedMap::contains to check if $x is in the SGLUnorderedMap if unsure.
@SG_FUNC [[nodiscard]] SGLUnorderedMap::Iterator begin();
Returns a iterator to the first key value pair in the SGLUnorderedMap.
@SG_NOTE SGLUnorderedMap iterators behave circularly. This is equivalent to running operator++ on SGLUnorderedMap::end.
@SG_NOTE SGLUnorderedMap::Iterator allows modifying the SGLUnorderedMap through it. If modification is not needed, use SGLUnorderedMap::ConstIterator instead. The SGLUnorderedMap::ConstIterator equivalent to this function is SGLUnorderedMap::constBegin.
@SG_WARN If the SGLUnorderedMap is empty, this is the same as SGLUnorderedMap::end.
@SG_FUNC [[nodiscard]] SGLUnorderedMap::Iterator end();
Returns a null iterator associated to this SGLUnorderedMap.
@SG_NOTE SGLUnorderedMap iterators behave circularly. This is equivalent to running operator-- on SGLUnorderedMap::begin.
@SG_NOTE SGLUnorderedMap::Iterator allows modifying the SGLUnorderedMap through it. If modification is not needed, use SGLUnorderedMap::ConstIterator instead. The SGLUnorderedMap::ConstIterator equivalent to this function is SGLUnorderedMap::constEnd.
@SG_WARN Attempting to access the key or value that this iterator points to is undefined behaviour.
@SG_FUNC [[nodiscard]] SGLUnorderedMap::ConstIterator constBegin() const;
Returns a constant iterator to the first key value pair in the SGLUnorderedMap.
@SG_NOTE SGLUnorderedMap iterators behave circularly. This is equivalent to running operator++ on SGLUnorderedMap::constEnd.
@SG_WARN If the SGLUnorderedMap is empty, this is the same as SGLUnorderedMap::constEnd.
@SG_FUNC [[nodiscard]] SGLUnorderedMap::ConstIterator constEnd() const;
Returns a null constant iterator associated to this SGLUnorderedMap.
@SG_NOTE SGLUnorderedMap iterators behave circularly. This is equivalent to running operator-- on SGLUnorderedMap::constBegin.
@SG_WARN Attempting to access the key or value that this iterator points to is undefined behaviour.
@SG_FUNC void erase(SGLUnorderedMap::Iterator& x);
Removes the key value pair associated with $x from the SGLUnorderedMap.
After the removal, $x which is passed as a reference, is decremented. This means that you do not have to do any special handling for removed elements when iterating over a SGLUnorderedMap.
@SG_WARN Do not write any special logic to modify iterators while removing elements from a SGLUnorderedMap in a loop, SGLUnorderedMap::erase handles this for you automatically.
@SG_FUNC [[nodiscard]] SGLUnorderedMap::Iterator find(const K& x);
Returns the iterator pointing to key $x.
@SG_NOTE SGLUnorderedMap::end is returned if $x is not in the SGLUnorderedMap.
@SG_FUNC [[nodiscard]] SGLUnorderedMap::ConstIterator find(const K& x) const;
Returns the constant iterator pointing to key $x.
@SG_NOTE SGLUnorderedMap::constEnd is returned if $x is not in the SGLUnorderedMap.

@SG_CPP_CLASS SGLUnorderedMap::Iterator
@SG_SHORT_DESCRP iterator for SGLUnorderedMap
@SG_LONG_DESCRP SGLUnorderedMap::Iterator is a iterator for SGLUnorderedMap and points towards a key value pair in the SGLUnorderedMap. This can be used to iterate over the SGLUnorderedMap sequentially. If you do not need to modify the SGLUnorderedMap while iterating, use SGLUnorderedMap::ConstIterator instead. @SG_FINDREP_HEADER_ONLY
@SG_IMPLE SGLUnorderedMap::Iterator stores a pointer to the memory location where SGLUnorderedMap keeps all its data.
@SG_FUNC SGLUnorderedMap::Iterator& operator++();
Increments the iterator to point towards the next key value pair and returns the new iterator.
@SG_NOTE SGLUnorderedMap::Iterator is circular, incrementing SGLUnorderedMap::end gives SGLUnorderedMap::begin and decrementing SGLUnorderedMap::begin gives SGLUnorderedMap::end.
@SG_FUNC SGLUnorderedMap::Iterator operator++(int);
Increments the iterator to point towards the next key value pair and returns the old iterator.
@SG_NOTE SGLUnorderedMap::Iterator is circular, incrementing SGLUnorderedMap::end gives SGLUnorderedMap::begin and decrementing SGLUnorderedMap::begin gives SGLUnorderedMap::end.
@SG_FUNC SGLUnorderedMap::Iterator& operator--();
Decrements the iterator to point towards the previous key value pair and returns the new iterator.
@SG_NOTE SGLUnorderedMap::Iterator is circular, incrementing SGLUnorderedMap::end gives SGLUnorderedMap::begin and decrementing SGLUnorderedMap::begin gives SGLUnorderedMap::end.
@SG_FUNC SGLUnorderedMap::Iterator operator--(int);
Decrements the iterator to point towards the previous key value pair and returns the old iterator.
@SG_NOTE SGLUnorderedMap::Iterator is circular, incrementing SGLUnorderedMap::end gives SGLUnorderedMap::begin and decrementing SGLUnorderedMap::begin gives SGLUnorderedMap::end.
@SG_FUNC bool operator==(SGLUnorderedMap::Iterator x);
Checks if this iterator points to the same key value pair as $x.
@SG_FUNC bool operator!=(SGLUnorderedMap::Iterator x);
Checks if this iterator points to a different key value pair from $x.
@SG_FUNC const K& key();
Returns the key in the key value pair that this iterator points to.
@SG_WARN If this iterator is SGLUnorderedMap::end, using this function results in undefined behaviour.
@SG_FUNC V& value();
Returns a reference to the value in the key value pair that this iterator points to.
@SG_NOTE This returns a reference and not a copy. Assigning to the returned reference (using it as a lvalue) modifies the SGLUnorderedMap.
@SG_WARN If this iterator is SGLUnorderedMap::end, using this function results in undefined behaviour.
@SG_PRIVATE_API int slot;
@SG_PRIVATE_API SGLUnorderedMap* associatedSet;
@SG_PRIVATE_API SGLUnorderedMap::Iterator(int x, SGLUnorderedMap* s);

@SG_CPP_CLASS SGLUnorderedMap::ConstIterator
@SG_SHORT_DESCRP constant iterator for SGLUnorderedMap
@SG_LONG_DESCRP SGLUnorderedMap::ConstIterator is a constant iterator for SGLUnorderedMap and points towards a key value pair in the SGLUnorderedMap. This can be used to iterate over the SGLUnorderedMap sequentially. Modification to the SGLUnorderedMap through a constant iterator is not possible. To do that, use a SGLUnorderedMap::Iterator instead. @SG_FINDREP_HEADER_ONLY
@SG_IMPLE SGLUnorderedMap::ConstIterator stores a pointer to the memory location where SGLUnorderedMap keeps all its data.
@SG_FUNC SGLUnorderedMap::ConstIterator& operator++();
Increments the constant iterator to point towards the next key value pair and returns the new constant iterator.
@SG_NOTE SGLUnorderedMap::ConstIterator is circular, incrementing SGLUnorderedMap::constEnd gives SGLUnorderedMap::constBegin and decrementing SGLUnorderedMap::constBegin gives SGLUnorderedMap::constEnd.
@SG_FUNC SGLUnorderedMap::ConstIterator operator++(int);
Increments the constant iterator to point towards the next key value pair and returns the old constant iterator.
@SG_NOTE SGLUnorderedMap::ConstIterator is circular, incrementing SGLUnorderedMap::constEnd gives SGLUnorderedMap::constBegin and decrementing SGLUnorderedMap::constBegin gives SGLUnorderedMap::constEnd.
@SG_FUNC SGLUnorderedMap::ConstIterator& operator--();
Decrements the constant iterator to point towards the previous key value pair and returns the new constant iterator.
@SG_NOTE SGLUnorderedMap::ConstIterator is circular, incrementing SGLUnorderedMap::constEnd gives SGLUnorderedMap::constBegin and decrementing SGLUnorderedMap::constBegin gives SGLUnorderedMap::constEnd.
@SG_FUNC SGLUnorderedMap::ConstIterator operator--(int);
Decrements the constant iterator to point towards the previous key value pair and returns the old constant iterator.
@SG_NOTE SGLUnorderedMap::ConstIterator is circular, incrementing SGLUnorderedMap::constEnd gives SGLUnorderedMap::constBegin and decrementing SGLUnorderedMap::constBegin gives SGLUnorderedMap::constEnd.
@SG_FUNC bool operator==(SGLUnorderedMap::ConstIterator x);
Checks if this constant iterator points to the same key value pair as $x.
@SG_FUNC bool operator!=(SGLUnorderedMap::ConstIterator x);
Checks if this constant iterator points to a different key value pair from $x.
@SG_FUNC const K& key();
Returns the key in the key value pair that this constant iterator points to.
@SG_WARN If this iterator is SGLUnorderedMap::constEnd, using this function results in undefined behaviour.
@SG_FUNC const V& value();
Returns the value in the key value pair that this constant iterator points to.
@SG_WARN If this iterator is SGLUnorderedMap::constEnd, using this function results in undefined behaviour.
@SG_PRIVATE_API int slot;
@SG_PRIVATE_API const SGLUnorderedMap* associatedSet;
@SG_PRIVATE_API SGLUnorderedMap::ConstIterator(int x, const SGLUnorderedMap* s);
