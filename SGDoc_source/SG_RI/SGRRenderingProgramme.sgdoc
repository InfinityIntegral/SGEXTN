@SG_CPP_CLASS SGRRenderingProgramme
@SG_SHORT_DESCRP provides interface for custom renderers to interact with the rendering pipeline
@SG_LONG_DESCRP SGRRenderingProgramme manages the shaders and rendering pipeline of @SG_FINDREP_RENDERER renderers, and provides access to functions setting up the rendering pipeline and uploading shader data. Unlike any other GPU framework, this is not tedious at all and is accessible to even beginners.
@SG_IMPLE @SG_FINDREP_RENDERER internally uses QRhi.
@SG_FUNC SGRRenderingProgramme(SGRBaseRenderer* renderControl);
Creates a SGRRenderingProgramme associated with the @SG_FINDREP_RENDERER renderer $renderControl.
@SG_NOTE $renderControl owns this SGRRenderingProgramme and will delete it when no longer needed.
@SG_WARN Passing nullptr to $renderControl is undefined behaviour.
@SG_PRIVATE_API QRhiGraphicsPipeline* pipeline;
@SG_PRIVATE_API SGRRendererNode* node;
@SG_PRIVATE_API QRhi* rhi;
@SG_PRIVATE_API bool shadersAreSet;
@SG_PRIVATE_API QRhiShaderStage* vertexShader;
@SG_PRIVATE_API QRhiShaderStage* fragmentShader;
@SG_FUNC void setShaderQSBFiles(const SGXString& vertexShaderPath, const SGXString& fragmentShaderPath);
Sets this SGRRenderingProgramme to use the vertex shader at $vertexShaderPath and the fragment shader at $fragmentShaderPath.
@SG_WARN The compiled shader must exist in the resource system. To ensure that, put the shader GLSL source code in the shaders folder. @SG_FINDREP_SHADER
@SG_PRIVATE_API bool vertexFormattingIsSet;
@SG_PRIVATE_API SGLVector<int>* vertexBufferObjects;
@SG_FUNC void addVertexBufferObject(int vertexSize) const;
Registers a vertex buffer object with each vertex having a size of $vertexSize bytes.
@SG_NOTE This does not create anything, it only tells the SGRRenderingProgramme that such a vertex buffer object will be used later.
@SG_NOTE The index of vertex buffer objects corresponds to the order in which they are declared using SGRRenderingProgramme::addVertexBufferObject, with the first one having index 0.
@SG_WARN Zero or negative $vertexSize is undefined behaviour.
@SG_PRIVATE_API SGLVector<SGRVertexProperty>* vertexProperties;
@SG_FUNC void addVertexProperty(int vertexBufferObjectIndex, int offsetFromVertexStart, int shaderDeclaredLocation, SGRGraphicsLanguageType::Type propertyType, int vectorLength) const;
Registers a vertex property corresponding to the in variable at location $shaderDeclaredLocation in the input shader, which is sourced from vertex buffer object number $vertexBufferObjectIndex at a offset of $offsetFromVertexStart bytes. This vertex shader in variable contains $vectorLength of the GLSL data type $propertyType.
@SG_NOTE This does not create anything, it just tells the SGRRenderingProgramme how to interpret vertex buffer objects.
@SG_WARN Forgetting to register any vertex shader in variable is undefined behaviour.
@SG_WARN Forgetting to bind the vertex buffer object before drawing is undefined behaviour.
@SG_WARN Passing a vertex buffer object that does not match the layout is undefined behaviour.
@SG_WARN Registering a vertex property that does not exist in the vertex shader is undefined behaviour.
@SG_WARN Negative $offsetFromVertexStart is undefined behaviour.
@SG_WARN Negative $vertexBufferObjectIndex is undefined behaviour.
@SG_WARN $vectorLength below 1 or above 4 is undefined behaviour.
@SG_FUNC void finaliseVertices();
Completes registering vertex related properties.
@SG_WARN Registering more vertex buffer objects or vertex properties after this has been called is undefined behaviour.
@SG_PRIVATE_API bool shaderResourceIsSet;
@SG_PRIVATE_API SGLVector<SGLPair<int, int>>* uniformBufferObjects;
@SG_PRIVATE_API SGLVector<int>* textureObjects;
@SG_FUNC void addUniformBufferObject(int std140AlignedSize, int shaderDeclaredBinding) const;
Adds a uniform buffer object with a size of $std140AlignedSize bytes attached to the binding point $shaderDeclaredBinding.
@SG_NOTE The actual buffer is internally managed by @SG_FINDREP_RENDERER.
@SG_WARN Binding point 0 is reserved for @SG_FINDREP_RENDERER internal uniform buffer object, $shaderDeclaredBinding being 0 will crash.
@SG_WARN $std140AlignedSize being wrong or not following std140 is undefined behaviour.
@SG_WARN $shaderDeclaredBinding not being in the shaders or wrong binding point being passed is undefined behaviour.
@SG_WARN Adding a texture as a uniform buffer object is undefined behaviour.
@SG_FUNC void addTexture(int shaderDeclaredBinding) const;
Adds a texture attached to the binding point $shaderDeclaredBinding.
@SG_NOTE The actual texture is internally managed by @SG_FINDREP_RENDERER, images can be uploaded using SGRImage.
@SG_NOTE Efficiently swapping textures frequently would need access to private API. This is likely to be changed in a future SGEXTN version.
@SG_WARN $shaderDeclaredBinding not being in the shaders or wrong binding point being passed is undefined behaviour.
@SG_PRIVATE_API QRhiShaderResourceBindings* shaderResources;
@SG_PRIVATE_API SGLVector<SGLPair<int, QRhiBuffer*>>* uniformBuffers;
@SG_PRIVATE_API SGLVector<SGLPair<int, SGRTexture*>>* textures;
@SG_FUNC void finaliseShaderResource();
Prepares textures and uniform buffer objects.
@SG_WARN Adding more textures and uniform buffer objects after this has been called is undefined behaviour.
@SG_FUNC void finaliseRenderingProgramme();
Prepares the SGRRenderingProgramme for usage.
@SG_WARN If any component of the SGRRenderingProgramme is not prepared yet, this will crash, but it will print a clear message telling you what need to be fixed.
@SG_WARN Modifying the SGRRenderingProgramme after this has been called is undefined behaviour.
@SG_WARN Using a SGRRenderingProgramme that has not been prepared yet will crash.
@SG_WARN Calling this outside of SGRBaseRenderer::initialise is undefined behaviour.
@SG_PRIVATE_API bool isFinalised;
@SG_PRIVATE_API QRhiResourceUpdateBatch* resourceUpdateOperation;
@SG_FUNC void updateDataBuffer(SGRDataBuffer* buffer, int startLocation, int dataSize, void* pointerToData) const;
Uploads $dataSize bytes of data from $pointerToData to an offset of $startLocation bytes into the buffer $buffer.
@SG_WARN Using this outside of SGRBaseRenderer::uploadShaderData is undefined behaviour.
@SG_WARN $buffer being nullptr is undefined behaviour.
@SG_WARN Negative $startLocation or $startLocation + $dataSize being more than or equal to length of $buffer is undefined behaviour.
@SG_WARN SGLArray or SGLVector where $pointerToData came from having a byte length below $dataSize is undefined behaviour.
@SG_WARN $pointerToData being nullptr is undefined behaviour.
@SG_FUNC void updateShaderUniforms(int shaderDeclaredBinding, int startLocation, int dataSize, void* pointerToData) const;
Uploads $dataSize bytes of data from $pointerToData to an offset of $startLocation bytes into the uniform buffer object at binding point $shaderDeclaredBinding.
@SG_WARN Using this outside of SGRBaseRenderer::uploadShaderData is undefined behaviour.
@SG_WARN Nonexistent $shaderDeclaredBinding is undefined behaviour.
@SG_WARN Negative $startLocation or $startLocation + $dataSize being more than or equal to length of the uniform buffer object at $shaderDeclaredBinding is undefined behaviour.
@SG_WARN SGLArray or SGLVector where $pointerToData came from having a byte length below $dataSize is undefined behaviour.
@SG_WARN $pointerToData being nullptr is undefined behaviour.
@SG_FUNC void updateTexture(int shaderDeclaredBinding, SGRImage* sourceImage) const;
Uploads $sourceImage to the texture at $shaderDeclaredBinding.
@SG_NOTE $sourceImage does not need to have the same size as the previously bound texture.
@SG_WARN Using this outside of SGRBaseRenderer::uploadShaderData is undefined behaviour.
@SG_WARN Nonexistent $shaderDeclaredBinding is undefined behaviour.
@SG_WARN $sourceImage being nullptr is undefined behaviour.
