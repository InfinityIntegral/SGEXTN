@SG_OTHERFILE_tutorials/full10 Full Tutorial Part 10
See @SG_ML_L004006herefull09 for the previous part of the tutorial.
In the previous part, we wrote the behaviour of the input field in the options page.
@SG_ML_BLANKLINE
@SG_ML_HEADER_ writing options page behaviour (final part)
Noe the options page is done (we will write the presets system later, ignore it for now), we need to extract data from the UI for processing by the application.
We can use SGWButton::getSelected, SGWInput::getInvalid, SGWColourPickerWidget::getColour, SGWInput::getTextAsInt, SGWInput::getTextAsFloat, and SGWInput::getTextAsString to do this.
Before we do that, we should first make a function SGCLPOptionsPage::submitOptions and call it whenever the submit button is pressed. By now you should already know how to do that. We will focus on implementing the function.
@SG_ML_BLANKLINE
First we check if the input field for the number of vertices is valid. If the value is relevant but it is not valid, then we prevent the user from actually submitting the options.
To warn the user about invalid input, we can use SGWNotify::pullDownNotify. To display informational messages, use SGWNotify::notify.
@SG_STARTCODEBLK
if((*SGCLPOptionsPage::polygonSideCountInput).getInvalid() == true && ((*SGCLPOptionsPage::patternPolygonButton).getSelected() == true || (*SGCLPOptionsPage::patternStarButton).getSelected() == true)){
    SGWNotify::pullDownNotify("invalid number of vertices chosen");
    return;
}
@SG_ENDCODEBLK
If this does not trigger, it would mean that everything is ok. In that case, we can save the chosen options for the next part of the application to process.
@SG_ML_BLANKLINE
When we turn off this UI page, the UI elements on screen will be destroyed and the data will be gone, so we have to save it in static variables first. We can declare the static variables first.
@SG_STARTCODEBLK
static SGXColourRGBA chosenBackgroundColour;
static SGXColourRGBA chosenForegroundColour;
enum Pattern{
    Circle,
    Polygon,
    Star,
    Fractal
};
static Pattern chosenPattern;
static int chosenVertexCount;
@SG_ENDCODEBLK
Here we use a enum for the pattern type as it gives better readability. In SGEXTN, unlike in Qt, there is no registration or MetaObject processing required for enums.
As usual, we have to declare these in the source file.
@SG_STARTCODEBLK
SGXColourRGBA SGCLPOptionsPage::chosenForegroundColour = SGXColourRGBA(255, 0, 200);
SGXColourRGBA SGCLPOptionsPage::chosenBackgroundColour = SGXColourRGBA(255, 255, 255);
SGCLPOptionsPage::Pattern SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Circle;
int SGCLPOptionsPage::chosenVertexCount = 3;
@SG_ENDCODEBLK
@SG_ML_BLANKLINE
Then we save everything into static variables.
@SG_STARTCODEBLK
SGCLPOptionsPage::chosenForegroundColour = (*SGCLPOptionsPage::foregroundColourPicker).getColour();
SGCLPOptionsPage::chosenBackgroundColour = SGCLPOptionsPage::chosenForegroundColour;
if((*SGCLPOptionsPage::backgroundUseCustomButton).getSelected() == true){SGCLPOptionsPage::chosenBackgroundColour = (*SGCLPOptionsPage::backgroundColourPicker).getColour();}
else{
    SGXColourHSLA backgroundColourHSLA(SGCLPOptionsPage::chosenBackgroundColour);
    if((*SGCLPOptionsPage::backgroundComplementaryHueButton).getSelected() == true){backgroundColourHSLA.invertHue();}
    if((*SGCLPOptionsPage::backgroundComplementarySaturationButton).getSelected() == true){backgroundColourHSLA.invertSaturation();}
    if((*SGCLPOptionsPage::backgroundComplementaryLightnessButton).getSelected() == true){backgroundColourHSLA.invertLightness();}
    SGCLPOptionsPage::chosenBackgroundColour = backgroundColourHSLA.toRGBA();
}
if((*SGCLPOptionsPage::patternCircleButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Circle;}
else if((*SGCLPOptionsPage::patternPolygonButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Polygon;}
else if((*SGCLPOptionsPage::patternStarButton).getSelected() == true){SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Star;}
else{SGCLPOptionsPage::chosenPattern = SGCLPOptionsPage::Fractal;}
SGCLPOptionsPage::chosenVertexCount = (*SGCLPOptionsPage::polygonSideCountInput).getTextAsInt(nullptr, 3, SGLIntLimits::maximum());
@SG_ENDCODEBLK
Note that we use SGWButton::getSelected to check if a selectable button is currently selected.
SGXColourRGBA and SGXColourHSLA have a wide variety of utility functions for colour processing. Most SGEXTN APIs take SGXColourRGBA as input and output, so for representing colours, SGXColourRGBA should always be used. If you need HSL stuff, you can convert a SGXColourRGBA to a SGXColourHSLA using the constructor of SGXColourHSLA that takes a SGXColourRGBA, process it, then convert it back using SGXColourHSLA::toRGBA.
@SG_ML_BLANKLINE
See @SG_ML_L004006herefull11 for the next part of the tutorial.
